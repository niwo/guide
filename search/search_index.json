{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"An elegant web framework designed to be simple, powerful and fast. Feature Overview # Spider-Gazelle employs some unique concepts, features, and design principles: Self documenting, can generate an OpenAPI description of your project Annotations are used to define & configure routes, filters and error handlers Implements strong parameter typing with customisable parsing Parses request bodies and serialises responses based on Accept and Content-Type headers Specs are simple to write, leveraging HotTopic Exceptions in development are helpful, leveraging Exception Page Puts you in control, customise command line options, when the server is started, how your app is configured etc Who builds it? # Place Technology are a fast-paced team of developers and designers based in Sydney and Brisbane, Australia. Github Organization Example apps # Spider-Gazelle Template Apple/Google Wallet Abstraction PlaceOS Core Staff API","title":"About"},{"location":"#feature-overview","text":"Spider-Gazelle employs some unique concepts, features, and design principles: Self documenting, can generate an OpenAPI description of your project Annotations are used to define & configure routes, filters and error handlers Implements strong parameter typing with customisable parsing Parses request bodies and serialises responses based on Accept and Content-Type headers Specs are simple to write, leveraging HotTopic Exceptions in development are helpful, leveraging Exception Page Puts you in control, customise command line options, when the server is started, how your app is configured etc","title":"Feature Overview"},{"location":"#who-builds-it","text":"Place Technology are a fast-paced team of developers and designers based in Sydney and Brisbane, Australia. Github Organization","title":"Who builds it?"},{"location":"#example-apps","text":"Spider-Gazelle Template Apple/Google Wallet Abstraction PlaceOS Core Staff API","title":"Example apps"},{"location":"SUMMARY/","text":"About Getting Started Routing Sessions and Cookies Writing Specs Self Documentation New Project Logging and instrumentation Command line options Deployment Source Documentation Aliases Action Controller Errors Responders Support Route Params Param errors Route errors Session","title":"SUMMARY"},{"location":"ActionController/aliases/","text":"alias AC # Alias definition ActionController","title":"Aliases"},{"location":"ActionController/aliases/#AC","text":"","title":"AC"},{"location":"Base/","text":"abstract class ActionController::Base inherits Reference # Included modules ActionController::Responders ActionController::Route::Builder Constants # AFTER_MAPPINGS = {} of Nil => Nil # klass => {function => options} AROUND_MAPPINGS = {} of Nil => Nil # klass => {function => options} BEFORE_MAPPINGS = {} of Nil => Nil # klass => {function => options} CONCRETE_CONTROLLERS = {} of Nil => Nil # Base route => klass name CRUD_METHODS = { \"index\" => { \"get\" , \"/\" , false }, \"new\" => { \"get\" , \"/new\" , false }, \"create\" => { \"post\" , \"/\" , false }, \"show\" => { \"get\" , \"/:id\" , true }, \"edit\" => { \"get\" , \"/:id/edit\" , true }, \"update\" => { \"patch\" , \"/:id\" , true }, \"replace\" => { \"put\" , \"/:id\" , true }, \"destroy\" => { \"delete\" , \"/:id\" , true }} # DEFAULT_PARAM_ID = {} of Nil => Nil # Route IDs params FILTER_TYPES = [ \"ROUTES\" , \"BEFORE\" , \"AROUND\" , \"AFTER\" , \"RESCUE\" , \"FORCE\" , \"SKIP\" ] of :: String # FORCE_MAPPINGS = {} of Nil => Nil # klass => {function => options} RESCUE_MAPPINGS = {} of Nil => Nil # klass => {function => options} ROUTES_MAPPINGS = {} of Nil => Nil # klass => {function => options} SKIP_MAPPINGS = {} of Nil => Nil # klass => {function => options} TEMPLATE_LAYOUT = {} of Nil => Nil # Template support TEMPLATE_PATH = { ActionController :: Base => \"./src/views/\" } of Nil => Nil # Constructors # .new ( context : HTTP::Server::Context , action_name : Symbol = :index , __head_request__ : Bool = false ) # View source Class methods # .__init_routes__ ( router ) # To support inheritance View source .__route_list__ # View source .__yield__ # View source .extract_params ( context : HTTP::Server::Context ) : URI :: Params # Extracts query and route params into a single URI::Params instance View source Methods # #__cookies__ : HTTP :: Cookies | :: Nil # View source #__session__ : Session | :: Nil # View source #action_name : Symbol # View source #client_ip : String # View source #context # View source #cookies : HTTP :: Cookies # View source #files : Hash ( String , Array ( ActionController :: BodyParser :: FileUpload )) | :: Nil # View source #form_data # View source #params : URI :: Params # View source #query_params ( * args , ** options ) # View source #query_params # View source #render_called : Bool # View source #request ( * args , ** options ) # View source #request # View source #request_content_type : String | :: Nil # View source #request_protocol # =============== Helper methods: =============== View source #response ( * args , ** options ) # View source #response # View source #route_params ( * args , ** options ) # View source #route_params # View source #session : Session # View source Macros # __build_filter_inheritance_macros__ # View source __build_filter_mappings__ # View source __create_route_methods__ # View source __define_filter_macro__ ( name , store , method = nil ) # View source __draw_routes__ # View source after_action ( method , only = nil , except = nil ) # View source around_action ( method , only = nil , except = nil ) # View source base ( name = nil ) # View source before_action ( method , only = nil , except = nil ) # View source delete ( path , function = nil , annotations = nil , reference = nil # View source force_ssl ( only = nil , except = nil ) # View source force_tls ( only = nil , except = nil ) # View source get ( path , function = nil , annotations = nil , reference = nil # View source id_param ( id ) # View source layout ( filename = nil ) # View source options ( path , function = nil , annotations = nil , reference = nil # View source partial ( partial , io = nil ) # View source patch ( path , function = nil , annotations = nil , reference = nil # View source post ( path , function = nil , annotations = nil , reference = nil # View source put ( path , function = nil , annotations = nil , reference = nil # View source rescue_from ( error_class , method = nil # View source skip_action ( method , only = nil , except = nil ) # View source template ( template = nil , partial = nil , layout = nil , io = nil ) # View source template_path ( path ) # View source ws ( path , function = nil , annotations = nil , reference = nil # View source","title":"::: ActionController::Base"},{"location":"Base/#ActionController::Base","text":"","title":"Base"},{"location":"Base/#ActionController::Base-constants","text":"","title":"Constants"},{"location":"Base/#ActionController::Base::AFTER_MAPPINGS","text":"klass => {function => options}","title":"AFTER_MAPPINGS"},{"location":"Base/#ActionController::Base::AROUND_MAPPINGS","text":"klass => {function => options}","title":"AROUND_MAPPINGS"},{"location":"Base/#ActionController::Base::BEFORE_MAPPINGS","text":"klass => {function => options}","title":"BEFORE_MAPPINGS"},{"location":"Base/#ActionController::Base::CONCRETE_CONTROLLERS","text":"Base route => klass name","title":"CONCRETE_CONTROLLERS"},{"location":"Base/#ActionController::Base::CRUD_METHODS","text":"","title":"CRUD_METHODS"},{"location":"Base/#ActionController::Base::DEFAULT_PARAM_ID","text":"Route IDs params","title":"DEFAULT_PARAM_ID"},{"location":"Base/#ActionController::Base::FILTER_TYPES","text":"","title":"FILTER_TYPES"},{"location":"Base/#ActionController::Base::FORCE_MAPPINGS","text":"klass => {function => options}","title":"FORCE_MAPPINGS"},{"location":"Base/#ActionController::Base::RESCUE_MAPPINGS","text":"klass => {function => options}","title":"RESCUE_MAPPINGS"},{"location":"Base/#ActionController::Base::ROUTES_MAPPINGS","text":"klass => {function => options}","title":"ROUTES_MAPPINGS"},{"location":"Base/#ActionController::Base::SKIP_MAPPINGS","text":"klass => {function => options}","title":"SKIP_MAPPINGS"},{"location":"Base/#ActionController::Base::TEMPLATE_LAYOUT","text":"Template support","title":"TEMPLATE_LAYOUT"},{"location":"Base/#ActionController::Base::TEMPLATE_PATH","text":"","title":"TEMPLATE_PATH"},{"location":"Base/#ActionController::Base-constructors","text":"","title":"Constructors"},{"location":"Base/#ActionController::Base.new(context,action_name,__head_request__)","text":"View source","title":".new"},{"location":"Base/#ActionController::Base-class-methods","text":"","title":"Class methods"},{"location":"Base/#ActionController::Base.__init_routes__(router)","text":"To support inheritance View source","title":".__init_routes__"},{"location":"Base/#ActionController::Base.__route_list__","text":"View source","title":".__route_list__"},{"location":"Base/#ActionController::Base.__yield__(inst,&)","text":"View source","title":".__yield__"},{"location":"Base/#ActionController::Base.extract_params(context)","text":"Extracts query and route params into a single URI::Params instance View source","title":".extract_params"},{"location":"Base/#ActionController::Base-methods","text":"","title":"Methods"},{"location":"Base/#ActionController::Base#__cookies__","text":"View source","title":"#__cookies__"},{"location":"Base/#ActionController::Base#__session__","text":"View source","title":"#__session__"},{"location":"Base/#ActionController::Base#action_name","text":"View source","title":"#action_name"},{"location":"Base/#ActionController::Base#client_ip","text":"View source","title":"#client_ip"},{"location":"Base/#ActionController::Base#context","text":"View source","title":"#context"},{"location":"Base/#ActionController::Base#cookies","text":"View source","title":"#cookies"},{"location":"Base/#ActionController::Base#files","text":"View source","title":"#files"},{"location":"Base/#ActionController::Base#form_data","text":"View source","title":"#form_data"},{"location":"Base/#ActionController::Base#params","text":"View source","title":"#params"},{"location":"Base/#ActionController::Base#query_params(*,**)","text":"View source","title":"#query_params"},{"location":"Base/#ActionController::Base#render_called","text":"View source","title":"#render_called"},{"location":"Base/#ActionController::Base#request(*,**)","text":"View source","title":"#request"},{"location":"Base/#ActionController::Base#request_content_type","text":"View source","title":"#request_content_type"},{"location":"Base/#ActionController::Base#request_protocol","text":"=============== Helper methods: =============== View source","title":"#request_protocol"},{"location":"Base/#ActionController::Base#response(*,**)","text":"View source","title":"#response"},{"location":"Base/#ActionController::Base#route_params(*,**)","text":"View source","title":"#route_params"},{"location":"Base/#ActionController::Base#session","text":"View source","title":"#session"},{"location":"Base/#ActionController::Base-macros","text":"","title":"Macros"},{"location":"Base/#ActionController::Base:__build_filter_inheritance_macros__","text":"View source","title":"__build_filter_inheritance_macros__"},{"location":"Base/#ActionController::Base:__build_filter_mappings__","text":"View source","title":"__build_filter_mappings__"},{"location":"Base/#ActionController::Base:__create_route_methods__","text":"View source","title":"__create_route_methods__"},{"location":"Base/#ActionController::Base:__define_filter_macro__(name,store,method)","text":"View source","title":"__define_filter_macro__"},{"location":"Base/#ActionController::Base:__draw_routes__","text":"View source","title":"__draw_routes__"},{"location":"Base/#ActionController::Base:after_action(method,only,except)","text":"View source","title":"after_action"},{"location":"Base/#ActionController::Base:around_action(method,only,except)","text":"View source","title":"around_action"},{"location":"Base/#ActionController::Base:base(name)","text":"View source","title":"base"},{"location":"Base/#ActionController::Base:before_action(method,only,except)","text":"View source","title":"before_action"},{"location":"Base/#ActionController::Base:delete(path,function,annotations,reference,&)","text":"View source","title":"delete"},{"location":"Base/#ActionController::Base:force_ssl(only,except)","text":"View source","title":"force_ssl"},{"location":"Base/#ActionController::Base:force_tls(only,except)","text":"View source","title":"force_tls"},{"location":"Base/#ActionController::Base:get(path,function,annotations,reference,&)","text":"View source","title":"get"},{"location":"Base/#ActionController::Base:id_param(id)","text":"View source","title":"id_param"},{"location":"Base/#ActionController::Base:layout(filename)","text":"View source","title":"layout"},{"location":"Base/#ActionController::Base:options(path,function,annotations,reference,&)","text":"View source","title":"options"},{"location":"Base/#ActionController::Base:partial(partial,io)","text":"View source","title":"partial"},{"location":"Base/#ActionController::Base:patch(path,function,annotations,reference,&)","text":"View source","title":"patch"},{"location":"Base/#ActionController::Base:post(path,function,annotations,reference,&)","text":"View source","title":"post"},{"location":"Base/#ActionController::Base:put(path,function,annotations,reference,&)","text":"View source","title":"put"},{"location":"Base/#ActionController::Base:rescue_from(error_class,method,&)","text":"View source","title":"rescue_from"},{"location":"Base/#ActionController::Base:skip_action(method,only,except)","text":"View source","title":"skip_action"},{"location":"Base/#ActionController::Base:template(template,partial,layout,io)","text":"View source","title":"template"},{"location":"Base/#ActionController::Base:template_path(path)","text":"View source","title":"template_path"},{"location":"Base/#ActionController::Base:ws(path,function,annotations,reference,&)","text":"View source","title":"ws"},{"location":"BodyParser/","text":"module ActionController::BodyParser # Constants # CONTENT_TYPES = { \"application/x-www-form-urlencoded\" : :url_encoded_form , \"application/x-url-encoded\" : :url_encoded_form , \"multipart/form-data\" : :multipart_form } # Class methods # .extract_form_data ( request , content_type , params : HTTP :: Params ) # ameba:disable Metrics/CyclomaticComplexity View source","title":"::: ActionController::BodyParser"},{"location":"BodyParser/#ActionController::BodyParser","text":"","title":"BodyParser"},{"location":"BodyParser/#ActionController::BodyParser-constants","text":"","title":"Constants"},{"location":"BodyParser/#ActionController::BodyParser::CONTENT_TYPES","text":"","title":"CONTENT_TYPES"},{"location":"BodyParser/#ActionController::BodyParser-class-methods","text":"","title":"Class methods"},{"location":"BodyParser/#ActionController::BodyParser.extract_form_data(request,content_type,params)","text":"ameba:disable Metrics/CyclomaticComplexity View source","title":".extract_form_data"},{"location":"BodyParser/FileUpload/","text":"struct ActionController::BodyParser::FileUpload inherits Struct # Constructors # .new ( name : String , headers : HTTP :: Headers , io : IO ) # View source .new ( part : HTTP :: FormData :: Part ) # View source Methods # #body : IO # View source #creation_time : Time | :: Nil # View source #filename : String | :: Nil # View source #headers : HTTP :: Headers # View source #modification_time : Time | :: Nil # View source #name : String # View source #read_time : Time | :: Nil # View source #size : UInt64 | :: Nil # View source","title":"::: ActionController::BodyParser::FileUpload"},{"location":"BodyParser/FileUpload/#ActionController::BodyParser::FileUpload","text":"","title":"FileUpload"},{"location":"BodyParser/FileUpload/#ActionController::BodyParser::FileUpload-constructors","text":"","title":"Constructors"},{"location":"BodyParser/FileUpload/#ActionController::BodyParser::FileUpload.new(name,headers,io)","text":"View source","title":".new"},{"location":"BodyParser/FileUpload/#ActionController::BodyParser::FileUpload-methods","text":"","title":"Methods"},{"location":"BodyParser/FileUpload/#ActionController::BodyParser::FileUpload#body","text":"View source","title":"#body"},{"location":"BodyParser/FileUpload/#ActionController::BodyParser::FileUpload#creation_time","text":"View source","title":"#creation_time"},{"location":"BodyParser/FileUpload/#ActionController::BodyParser::FileUpload#filename","text":"View source","title":"#filename"},{"location":"BodyParser/FileUpload/#ActionController::BodyParser::FileUpload#headers","text":"View source","title":"#headers"},{"location":"BodyParser/FileUpload/#ActionController::BodyParser::FileUpload#modification_time","text":"View source","title":"#modification_time"},{"location":"BodyParser/FileUpload/#ActionController::BodyParser::FileUpload#name","text":"View source","title":"#name"},{"location":"BodyParser/FileUpload/#ActionController::BodyParser::FileUpload#read_time","text":"View source","title":"#read_time"},{"location":"BodyParser/FileUpload/#ActionController::BodyParser::FileUpload#size","text":"View source","title":"#size"},{"location":"Config/environment/","text":"module ActionController # Constants # Log = :: Log . for ( \"action-controller\" ) # VERSION = \"5.1.2\" # Class methods # .default_backend ( io = STDOUT , formatter = default_formatter ) # View source .default_formatter # View source .json_formatter # View source .log_metadata_to_raw ( metadata ) # View source","title":"Source Documentation"},{"location":"Config/environment/#ActionController","text":"","title":"ActionController"},{"location":"Config/environment/#ActionController-constants","text":"","title":"Constants"},{"location":"Config/environment/#ActionController::Log","text":"","title":"Log"},{"location":"Config/environment/#ActionController::VERSION","text":"","title":"VERSION"},{"location":"Config/environment/#ActionController-class-methods","text":"","title":"Class methods"},{"location":"Config/environment/#ActionController.default_backend(io,formatter)","text":"View source","title":".default_backend"},{"location":"Config/environment/#ActionController.default_formatter","text":"View source","title":".default_formatter"},{"location":"Config/environment/#ActionController.json_formatter","text":"View source","title":".json_formatter"},{"location":"Config/environment/#ActionController.log_metadata_to_raw(metadata)","text":"View source","title":".log_metadata_to_raw"},{"location":"CookieSizeExceeded/","text":"class ActionController::CookieSizeExceeded inherits ActionController::Error #","title":"::: ActionController::CookieSizeExceeded"},{"location":"CookieSizeExceeded/#ActionController::CookieSizeExceeded","text":"","title":"CookieSizeExceeded"},{"location":"Error/","text":"class ActionController::Error inherits Exception # Direct known subclasses ActionController::CookieSizeExceeded ActionController::InvalidRoute ActionController::InvalidSignature","title":"Errors"},{"location":"Error/#ActionController::Error","text":"","title":"Error"},{"location":"ErrorHandler/","text":"module ActionController::ErrorHandler # Constructors # .new ( production : Bool = false , persist_headers = [] of String ) # View source","title":"::: ActionController::ErrorHandler"},{"location":"ErrorHandler/#ActionController::ErrorHandler","text":"","title":"ErrorHandler"},{"location":"ErrorHandler/#ActionController::ErrorHandler-constructors","text":"","title":"Constructors"},{"location":"ErrorHandler/#ActionController::ErrorHandler.new(production,persist_headers)","text":"View source","title":".new"},{"location":"ErrorHandlerBase/","text":"module ActionController::ErrorHandlerBase # Direct including types ActionController::ErrorHandlerDevelopment ActionController::ErrorHandlerProduction Constants # ACCEPT_SEPARATOR_REGEX = /,\\s*/ # Constructors # .new ( headers : Array ( String )) # View source Methods # #accepts_formats ( request ) # View source #reset ( response ) # View source","title":"::: ActionController::ErrorHandlerBase"},{"location":"ErrorHandlerBase/#ActionController::ErrorHandlerBase","text":"","title":"ErrorHandlerBase"},{"location":"ErrorHandlerBase/#ActionController::ErrorHandlerBase-constants","text":"","title":"Constants"},{"location":"ErrorHandlerBase/#ActionController::ErrorHandlerBase::ACCEPT_SEPARATOR_REGEX","text":"","title":"ACCEPT_SEPARATOR_REGEX"},{"location":"ErrorHandlerBase/#ActionController::ErrorHandlerBase-constructors","text":"","title":"Constructors"},{"location":"ErrorHandlerBase/#ActionController::ErrorHandlerBase.new(headers)","text":"View source","title":".new"},{"location":"ErrorHandlerBase/#ActionController::ErrorHandlerBase-methods","text":"","title":"Methods"},{"location":"ErrorHandlerBase/#ActionController::ErrorHandlerBase#accepts_formats(request)","text":"View source","title":"#accepts_formats"},{"location":"ErrorHandlerBase/#ActionController::ErrorHandlerBase#reset(response)","text":"View source","title":"#reset"},{"location":"ErrorHandlerDevelopment/","text":"class ActionController::ErrorHandlerDevelopment inherits Reference # Included modules ActionController::ErrorHandlerBase HTTP::Handler Methods # #call ( context ) # View source","title":"::: ActionController::ErrorHandlerDevelopment"},{"location":"ErrorHandlerDevelopment/#ActionController::ErrorHandlerDevelopment","text":"","title":"ErrorHandlerDevelopment"},{"location":"ErrorHandlerDevelopment/#ActionController::ErrorHandlerDevelopment-methods","text":"","title":"Methods"},{"location":"ErrorHandlerDevelopment/#ActionController::ErrorHandlerDevelopment#call(context)","text":"View source","title":"#call"},{"location":"ErrorHandlerProduction/","text":"class ActionController::ErrorHandlerProduction inherits Reference # Included modules ActionController::ErrorHandlerBase HTTP::Handler Methods # #call ( context ) # View source","title":"::: ActionController::ErrorHandlerProduction"},{"location":"ErrorHandlerProduction/#ActionController::ErrorHandlerProduction","text":"","title":"ErrorHandlerProduction"},{"location":"ErrorHandlerProduction/#ActionController::ErrorHandlerProduction-methods","text":"","title":"Methods"},{"location":"ErrorHandlerProduction/#ActionController::ErrorHandlerProduction#call(context)","text":"View source","title":"#call"},{"location":"ExceptionPage/","text":"class ActionController::ExceptionPage inherits ExceptionPage # Methods # #styles : Styles # View source","title":"::: ActionController::ExceptionPage"},{"location":"ExceptionPage/#ActionController::ExceptionPage","text":"","title":"ExceptionPage"},{"location":"ExceptionPage/#ActionController::ExceptionPage-methods","text":"","title":"Methods"},{"location":"ExceptionPage/#ActionController::ExceptionPage#styles","text":"View source","title":"#styles"},{"location":"FileHandler/","text":"class ActionController::FileHandler inherits HTTP::StaticFileHandler # This is deprecated in favour of the built in MIME store and handlers this is updated to provide compatibility but will be removed in the future","title":"::: ActionController::FileHandler"},{"location":"FileHandler/#ActionController::FileHandler","text":"This is deprecated in favour of the built in MIME store and handlers this is updated to provide compatibility but will be removed in the future","title":"FileHandler"},{"location":"FileHandler/MIME_TYPES/","text":"class ActionController::FileHandler::MIME_TYPES inherits Reference # Class methods # .[]= ( key , value ) # ameba:disable Style/TypeNames View source","title":"::: ActionController::FileHandler::MIME_TYPES"},{"location":"FileHandler/MIME_TYPES/#ActionController::FileHandler::MIME_TYPES","text":"","title":"MIME_TYPES"},{"location":"FileHandler/MIME_TYPES/#ActionController::FileHandler::MIME_TYPES-class-methods","text":"","title":"Class methods"},{"location":"FileHandler/MIME_TYPES/#ActionController::FileHandler::MIME_TYPES.[]=(key,value)","text":"ameba:disable Style/TypeNames View source","title":".[]="},{"location":"InvalidRoute/","text":"class ActionController::InvalidRoute inherits ActionController::Error #","title":"::: ActionController::InvalidRoute"},{"location":"InvalidRoute/#ActionController::InvalidRoute","text":"","title":"InvalidRoute"},{"location":"InvalidSignature/","text":"class ActionController::InvalidSignature inherits ActionController::Error #","title":"::: ActionController::InvalidSignature"},{"location":"InvalidSignature/#ActionController::InvalidSignature","text":"","title":"InvalidSignature"},{"location":"LogHandler/","text":"class ActionController::LogHandler inherits Reference # A handler that logs the request method, resource, status code, and the time taken to execute. Included modules HTTP::Handler Constructors # .new ( filter : Array ( String ) = [] of String , log : ActionController::LogHandler::Event = Event :: Response , ms : Bool = false , generate_id : Bool = true ) # Creates a new LogHandler for inserting into middlewhere. Use filter to specified any keys that may appear in request params that should be redacted prior to passing to the logging backend. This may include secrets or PII that should not leave the bounds of this system. log can be used to specify what sections of the request lifecycle to log. The defaults to the response (either valid or error) only, however support is also provide for request entry logging for development environments. By default, request times will include a unit. Set ms to instead always use milliseconds for simpler external perf monitoring. View source Methods # #call ( context : HTTP::Server::Context ) : Nil # View source","title":"::: ActionController::LogHandler"},{"location":"LogHandler/#ActionController::LogHandler","text":"A handler that logs the request method, resource, status code, and the time taken to execute.","title":"LogHandler"},{"location":"LogHandler/#ActionController::LogHandler-constructors","text":"","title":"Constructors"},{"location":"LogHandler/#ActionController::LogHandler.new(filter,log,ms,generate_id)","text":"Creates a new LogHandler for inserting into middlewhere. Use filter to specified any keys that may appear in request params that should be redacted prior to passing to the logging backend. This may include secrets or PII that should not leave the bounds of this system. log can be used to specify what sections of the request lifecycle to log. The defaults to the response (either valid or error) only, however support is also provide for request entry logging for development environments. By default, request times will include a unit. Set ms to instead always use milliseconds for simpler external perf monitoring. View source","title":".new"},{"location":"LogHandler/#ActionController::LogHandler-methods","text":"","title":"Methods"},{"location":"LogHandler/#ActionController::LogHandler#call(context)","text":"View source","title":"#call"},{"location":"LogHandler/Event/","text":"enum ActionController::LogHandler::Event # Events that occur within the request lifecycle. Members # Request = 1 # Response = 2 # Class methods # .all # View source Methods # #none? # View source #request? # View source #response? # View source","title":"::: ActionController::LogHandler::Event"},{"location":"LogHandler/Event/#ActionController::LogHandler::Event","text":"Events that occur within the request lifecycle.","title":"Event"},{"location":"LogHandler/Event/#ActionController::LogHandler::Event-members","text":"","title":"Members"},{"location":"LogHandler/Event/#ActionController::LogHandler::Event::Request","text":"","title":"Request"},{"location":"LogHandler/Event/#ActionController::LogHandler::Event::Response","text":"","title":"Response"},{"location":"LogHandler/Event/#ActionController::LogHandler::Event-class-methods","text":"","title":"Class methods"},{"location":"LogHandler/Event/#ActionController::LogHandler::Event.all","text":"View source","title":".all"},{"location":"LogHandler/Event/#ActionController::LogHandler::Event-methods","text":"","title":"Methods"},{"location":"LogHandler/Event/#ActionController::LogHandler::Event#none?","text":"View source","title":"#none?"},{"location":"LogHandler/Event/#ActionController::LogHandler::Event#request?","text":"View source","title":"#request?"},{"location":"LogHandler/Event/#ActionController::LogHandler::Event#response?","text":"View source","title":"#response?"},{"location":"MessageEncryptor/","text":"class ActionController::MessageEncryptor inherits Reference # Constructors # .new ( secret : String , cipher_algorithm : String = \"aes-256-cbc\" , digest : OpenSSL :: Algorithm = :sha1 ) # View source Methods # #decrypt ( value : Bytes ) # View source #encrypt ( value ) # View source #encrypt_and_sign ( value : Slice ( UInt8 )) : String # Encrypt and sign a message. We need to sign the message in order to avoid padding attacks. Reference: http://www.limited-entropy.com/padding-oracle-attacks . View source #encrypt_and_sign ( value : String ) : String # View source #extract ( value ) # View source #prepare ( value ) # View source #verifier : MessageVerifier # View source #verify_and_decrypt ( value : String ) : String # Verify and Decrypt a message. We need to verify the message in order to avoid padding attacks. Reference: http://www.limited-entropy.com/padding-oracle-attacks . View source","title":"::: ActionController::MessageEncryptor"},{"location":"MessageEncryptor/#ActionController::MessageEncryptor","text":"","title":"MessageEncryptor"},{"location":"MessageEncryptor/#ActionController::MessageEncryptor-constructors","text":"","title":"Constructors"},{"location":"MessageEncryptor/#ActionController::MessageEncryptor.new(secret,cipher_algorithm,digest)","text":"View source","title":".new"},{"location":"MessageEncryptor/#ActionController::MessageEncryptor-methods","text":"","title":"Methods"},{"location":"MessageEncryptor/#ActionController::MessageEncryptor#decrypt(value)","text":"View source","title":"#decrypt"},{"location":"MessageEncryptor/#ActionController::MessageEncryptor#encrypt(value)","text":"View source","title":"#encrypt"},{"location":"MessageEncryptor/#ActionController::MessageEncryptor#encrypt_and_sign(value)","text":"Encrypt and sign a message. We need to sign the message in order to avoid padding attacks. Reference: http://www.limited-entropy.com/padding-oracle-attacks . View source","title":"#encrypt_and_sign"},{"location":"MessageEncryptor/#ActionController::MessageEncryptor#encrypt_and_sign(value)","text":"View source","title":"#encrypt_and_sign"},{"location":"MessageEncryptor/#ActionController::MessageEncryptor#extract(value)","text":"View source","title":"#extract"},{"location":"MessageEncryptor/#ActionController::MessageEncryptor#prepare(value)","text":"View source","title":"#prepare"},{"location":"MessageEncryptor/#ActionController::MessageEncryptor#verifier","text":"View source","title":"#verifier"},{"location":"MessageEncryptor/#ActionController::MessageEncryptor#verify_and_decrypt(value)","text":"Verify and Decrypt a message. We need to verify the message in order to avoid padding attacks. Reference: http://www.limited-entropy.com/padding-oracle-attacks . View source","title":"#verify_and_decrypt"},{"location":"MessageVerifier/","text":"class ActionController::MessageVerifier inherits Reference # Constructors # .new ( secret : String , digest : OpenSSL :: Algorithm = :sha1 ) # View source Methods # #extract ( value ) # View source #generate ( value : String | Bytes ) # View source #prepare ( value ) # View source #valid_message? ( data , digest ) # View source #verified ( signed_message : String ) # View source #verify ( signed_message ) : String # View source #verify_raw ( signed_message : String ) : Bytes # View source","title":"::: ActionController::MessageVerifier"},{"location":"MessageVerifier/#ActionController::MessageVerifier","text":"","title":"MessageVerifier"},{"location":"MessageVerifier/#ActionController::MessageVerifier-constructors","text":"","title":"Constructors"},{"location":"MessageVerifier/#ActionController::MessageVerifier.new(secret,digest)","text":"View source","title":".new"},{"location":"MessageVerifier/#ActionController::MessageVerifier-methods","text":"","title":"Methods"},{"location":"MessageVerifier/#ActionController::MessageVerifier#extract(value)","text":"View source","title":"#extract"},{"location":"MessageVerifier/#ActionController::MessageVerifier#generate(value)","text":"View source","title":"#generate"},{"location":"MessageVerifier/#ActionController::MessageVerifier#prepare(value)","text":"View source","title":"#prepare"},{"location":"MessageVerifier/#ActionController::MessageVerifier#valid_message?(data,digest)","text":"View source","title":"#valid_message?"},{"location":"MessageVerifier/#ActionController::MessageVerifier#verified(signed_message)","text":"View source","title":"#verified"},{"location":"MessageVerifier/#ActionController::MessageVerifier#verify(signed_message)","text":"View source","title":"#verify"},{"location":"MessageVerifier/#ActionController::MessageVerifier#verify_raw(signed_message)","text":"View source","title":"#verify_raw"},{"location":"Responders/","text":"module ActionController::Responders # Direct including types ActionController::Base Constants # ACCEPT_SEPARATOR_REGEX = /,\\s*/ # MIME_TYPES = { binary : \"application/octet-stream\" , json : \"application/json\" , xml : \"application/xml\" , text : \"text/plain\" , html : \"text/html\" , yaml : \"text/yaml\" } # REDIRECTION_CODES = { multiple_choices : 300 , moved_permanently : 301 , found : 302 , see_other : 303 , not_modified : 304 , use_proxy : 305 , temporary_redirect : 307 , permanent_redirect : 308 } # STATUS_CODES = { continue : 100 , switching_protocols : 101 , processing : 102 , ok : 200 , created : 201 , accepted : 202 , non_authoritative_information : 203 , no_content : 204 , reset_content : 205 , partial_content : 206 , multi_status : 207 , already_reported : 208 , im_used : 226 , bad_request : 400 , unauthorized : 401 , payment_required : 402 , forbidden : 403 , not_found : 404 , method_not_allowed : 405 , not_acceptable : 406 , proxy_authentication_required : 407 , request_timeout : 408 , conflict : 409 , gone : 410 , length_required : 411 , precondition_failed : 412 , payload_too_large : 413 , uri_too_long : 414 , unsupported_media_type : 415 , range_not_satisfiable : 416 , expectation_failed : 417 , misdirected_request : 421 , unprocessable_entity : 422 , locked : 423 , failed_dependency : 424 , upgrade_required : 426 , precondition_required : 428 , too_many_requests : 429 , request_header_fields_too_large : 431 , unavailable_for_legal_reasons : 451 , internal_server_error : 500 , not_implemented : 501 , bad_gateway : 502 , service_unavailable : 503 , gateway_timeout : 504 , http_version_not_supported : 505 , variant_also_negotiates : 506 , insufficient_storage : 507 , loop_detected : 508 , not_extended : 510 , network_authentication_required : 511 } # Methods # #accepts_formats # Extracts the mime types from the Accept header View source Macros # head ( status ) # View source redirect_to ( path , status = :found ) # View source render ( status = :ok , head = nil , json = nil , yaml = nil , xml = nil , html = nil , text = nil , binary = nil , template = nil , partial = nil , layout = nil ) # View source respond_with ( status = :ok # View source","title":"Responders"},{"location":"Responders/#ActionController::Responders","text":"","title":"Responders"},{"location":"Responders/#ActionController::Responders-constants","text":"","title":"Constants"},{"location":"Responders/#ActionController::Responders::ACCEPT_SEPARATOR_REGEX","text":"","title":"ACCEPT_SEPARATOR_REGEX"},{"location":"Responders/#ActionController::Responders::MIME_TYPES","text":"","title":"MIME_TYPES"},{"location":"Responders/#ActionController::Responders::REDIRECTION_CODES","text":"","title":"REDIRECTION_CODES"},{"location":"Responders/#ActionController::Responders::STATUS_CODES","text":"","title":"STATUS_CODES"},{"location":"Responders/#ActionController::Responders-methods","text":"","title":"Methods"},{"location":"Responders/#ActionController::Responders#accepts_formats","text":"Extracts the mime types from the Accept header View source","title":"#accepts_formats"},{"location":"Responders/#ActionController::Responders-macros","text":"","title":"Macros"},{"location":"Responders/#ActionController::Responders:head(status)","text":"View source","title":"head"},{"location":"Responders/#ActionController::Responders:redirect_to(path,status)","text":"View source","title":"redirect_to"},{"location":"Responders/#ActionController::Responders:render(status,head,json,yaml,xml,html,text,binary,template,partial,layout)","text":"View source","title":"render"},{"location":"Responders/#ActionController::Responders:respond_with(status,&)","text":"View source","title":"respond_with"},{"location":"Responders/SelectResponse/","text":"class ActionController::Responders::SelectResponse inherits Reference # Helper class for selecting the response to render / execute Constants # ACCEPTED_FORMATS = { \"text/html\" : :html , \"application/xml\" : :xml , \"text/xml\" : :xml , \"application/json\" : :json , \"text/plain\" : :text , \"application/octet-stream\" : :binary , \"text/yaml\" : :yaml , \"text/x-yaml\" : :yaml , \"application/yaml\" : :yaml , \"application/x-yaml\" : :yaml } # Constructors # .new ( response : HTTP :: Server :: Response , formats , head_request : Bool ) # View source Class methods # .accepts ( accepts_formats ) # Creates an ordered list of supported formats with requested mime types View source Methods # #build_response # Respond appropriately View source #options # View source #responses # Build a list of possible responses to the request View source Macros # binary ( obj = nil # View source html ( obj = nil # View source json ( obj = nil # View source text ( obj = nil # View source xml ( obj = nil # View source yaml ( obj = nil # View source","title":"::: ActionController::Responders::SelectResponse"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse","text":"Helper class for selecting the response to render / execute","title":"SelectResponse"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse-constants","text":"","title":"Constants"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse::ACCEPTED_FORMATS","text":"","title":"ACCEPTED_FORMATS"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse-constructors","text":"","title":"Constructors"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse.new(response,formats,head_request)","text":"View source","title":".new"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse-class-methods","text":"","title":"Class methods"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse.accepts(accepts_formats)","text":"Creates an ordered list of supported formats with requested mime types View source","title":".accepts"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse-methods","text":"","title":"Methods"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse#build_response","text":"Respond appropriately View source","title":"#build_response"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse#options","text":"View source","title":"#options"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse#responses(&)","text":"Build a list of possible responses to the request View source","title":"#responses"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse-macros","text":"","title":"Macros"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse:binary(obj,&)","text":"View source","title":"binary"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse:html(obj,&)","text":"View source","title":"html"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse:json(obj,&)","text":"View source","title":"json"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse:text(obj,&)","text":"View source","title":"text"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse:xml(obj,&)","text":"View source","title":"xml"},{"location":"Responders/SelectResponse/#ActionController::Responders::SelectResponse:yaml(obj,&)","text":"View source","title":"yaml"},{"location":"Route/","text":"module ActionController::Route #","title":"::: ActionController::Route"},{"location":"Route/#ActionController::Route","text":"","title":"Route"},{"location":"Route/Builder/","text":"module ActionController::Route::Builder # Direct including types ActionController::Base Constants # DEFAULT_PARSER = [ \"application/json\" ] # DEFAULT_RESPONDER = [ \"application/json\" ] # PARSERS = { \"application/json\" => do | klass , body_io | klass . from_json ( body_io . gets_to_end ) end } of Nil => Nil # RESPONDERS = { \"application/json\" => do | io , result | result . to_json ( io ) end } of Nil => Nil # ROUTE_FUNCTIONS = {} of Nil => Nil # Macros # __build_transformer_functions__ # View source __parse_inferred_routes__ # View source add_parser # View source add_responder # View source default_parser ( content_type ) # View source default_responder ( content_type ) # View source","title":"::: ActionController::Route::Builder"},{"location":"Route/Builder/#ActionController::Route::Builder","text":"","title":"Builder"},{"location":"Route/Builder/#ActionController::Route::Builder-constants","text":"","title":"Constants"},{"location":"Route/Builder/#ActionController::Route::Builder::DEFAULT_PARSER","text":"","title":"DEFAULT_PARSER"},{"location":"Route/Builder/#ActionController::Route::Builder::DEFAULT_RESPONDER","text":"","title":"DEFAULT_RESPONDER"},{"location":"Route/Builder/#ActionController::Route::Builder::PARSERS","text":"","title":"PARSERS"},{"location":"Route/Builder/#ActionController::Route::Builder::RESPONDERS","text":"","title":"RESPONDERS"},{"location":"Route/Builder/#ActionController::Route::Builder::ROUTE_FUNCTIONS","text":"","title":"ROUTE_FUNCTIONS"},{"location":"Route/Builder/#ActionController::Route::Builder-macros","text":"","title":"Macros"},{"location":"Route/Builder/#ActionController::Route::Builder:__build_transformer_functions__","text":"View source","title":"__build_transformer_functions__"},{"location":"Route/Builder/#ActionController::Route::Builder:__parse_inferred_routes__","text":"View source","title":"__parse_inferred_routes__"},{"location":"Route/Builder/#ActionController::Route::Builder:add_parser(content_type,&)","text":"View source","title":"add_parser"},{"location":"Route/Builder/#ActionController::Route::Builder:add_responder(content_type,&)","text":"View source","title":"add_responder"},{"location":"Route/Builder/#ActionController::Route::Builder:default_parser(content_type)","text":"View source","title":"default_parser"},{"location":"Route/Builder/#ActionController::Route::Builder:default_responder(content_type)","text":"View source","title":"default_responder"},{"location":"Route/DELETE/","text":"annotation ActionController::Route::DELETE #","title":"::: ActionController::Route::DELETE"},{"location":"Route/DELETE/#ActionController::Route::DELETE","text":"","title":"DELETE"},{"location":"Route/Error/","text":"class ActionController::Route::Error inherits Exception # Direct known subclasses ActionController::Route::NotAcceptable ActionController::Route::UnsupportedMediaType Constructors # .new ( message : String? = nil , accepts : Array ( String )? = nil ) # View source Methods # #accepts : Array ( String ) | :: Nil # View source","title":"Route errors"},{"location":"Route/Error/#ActionController::Route::Error","text":"","title":"Error"},{"location":"Route/Error/#ActionController::Route::Error-constructors","text":"","title":"Constructors"},{"location":"Route/Error/#ActionController::Route::Error.new(message,accepts)","text":"View source","title":".new"},{"location":"Route/Error/#ActionController::Route::Error-methods","text":"","title":"Methods"},{"location":"Route/Error/#ActionController::Route::Error#accepts","text":"View source","title":"#accepts"},{"location":"Route/Exception/","text":"annotation ActionController::Route::Exception #","title":"::: ActionController::Route::Exception"},{"location":"Route/Exception/#ActionController::Route::Exception","text":"","title":"Exception"},{"location":"Route/Filter/","text":"annotation ActionController::Route::Filter #","title":"::: ActionController::Route::Filter"},{"location":"Route/Filter/#ActionController::Route::Filter","text":"","title":"Filter"},{"location":"Route/GET/","text":"annotation ActionController::Route::GET #","title":"::: ActionController::Route::GET"},{"location":"Route/GET/#ActionController::Route::GET","text":"","title":"GET"},{"location":"Route/NotAcceptable/","text":"class ActionController::Route::NotAcceptable inherits ActionController::Route::Error # we don't support any of the accepted response content types","title":"::: ActionController::Route::NotAcceptable"},{"location":"Route/NotAcceptable/#ActionController::Route::NotAcceptable","text":"we don't support any of the accepted response content types","title":"NotAcceptable"},{"location":"Route/OPTIONS/","text":"annotation ActionController::Route::OPTIONS #","title":"::: ActionController::Route::OPTIONS"},{"location":"Route/OPTIONS/#ActionController::Route::OPTIONS","text":"","title":"OPTIONS"},{"location":"Route/PATCH/","text":"annotation ActionController::Route::PATCH #","title":"::: ActionController::Route::PATCH"},{"location":"Route/PATCH/#ActionController::Route::PATCH","text":"","title":"PATCH"},{"location":"Route/POST/","text":"annotation ActionController::Route::POST #","title":"::: ActionController::Route::POST"},{"location":"Route/POST/#ActionController::Route::POST","text":"","title":"POST"},{"location":"Route/PUT/","text":"annotation ActionController::Route::PUT #","title":"::: ActionController::Route::PUT"},{"location":"Route/PUT/#ActionController::Route::PUT","text":"","title":"PUT"},{"location":"Route/Param/","text":"module ActionController::Route::Param #","title":"::: ActionController::Route::Param"},{"location":"Route/Param/#ActionController::Route::Param","text":"","title":"Param"},{"location":"Route/Param/Conversion/","text":"abstract struct ActionController::Route::Param::Conversion inherits Struct # The method for building in support of different route params Direct known subclasses ActionController::Route::Param::ConvertBigDecimal ActionController::Route::Param::ConvertBigFloat ActionController::Route::Param::ConvertBigInt ActionController::Route::Param::ConvertBool ActionController::Route::Param::ConvertChar ActionController::Route::Param::ConvertFloat32 ActionController::Route::Param::ConvertFloat64 ActionController::Route::Param::ConvertInt128 ActionController::Route::Param::ConvertInt16 ActionController::Route::Param::ConvertInt32 ActionController::Route::Param::ConvertInt64 ActionController::Route::Param::ConvertInt8 ActionController::Route::Param::ConvertString ActionController::Route::Param::ConvertTime ActionController::Route::Param::ConvertUInt128 ActionController::Route::Param::ConvertUInt16 ActionController::Route::Param::ConvertUInt32 ActionController::Route::Param::ConvertUInt64 ActionController::Route::Param::ConvertUInt8 Constructors # .new # View source Methods # abstract #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source #initialize # View source","title":"Params"},{"location":"Route/Param/Conversion/#ActionController::Route::Param::Conversion","text":"The method for building in support of different route params","title":"Conversion"},{"location":"Route/Param/Conversion/#ActionController::Route::Param::Conversion-constructors","text":"","title":"Constructors"},{"location":"Route/Param/Conversion/#ActionController::Route::Param::Conversion.new","text":"View source","title":".new"},{"location":"Route/Param/Conversion/#ActionController::Route::Param::Conversion-methods","text":"","title":"Methods"},{"location":"Route/Param/Conversion/#ActionController::Route::Param::Conversion#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/Conversion/#ActionController::Route::Param::Conversion#initialize","text":"View source","title":"#initialize"},{"location":"Route/Param/ConvertBigDecimal/","text":"struct ActionController::Route::Param::ConvertBigDecimal inherits ActionController::Route::Param::Conversion # Big converters Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertBigDecimal"},{"location":"Route/Param/ConvertBigDecimal/#ActionController::Route::Param::ConvertBigDecimal","text":"Big converters","title":"ConvertBigDecimal"},{"location":"Route/Param/ConvertBigDecimal/#ActionController::Route::Param::ConvertBigDecimal-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertBigDecimal/#ActionController::Route::Param::ConvertBigDecimal#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertBigFloat/","text":"struct ActionController::Route::Param::ConvertBigFloat inherits ActionController::Route::Param::Conversion # Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertBigFloat"},{"location":"Route/Param/ConvertBigFloat/#ActionController::Route::Param::ConvertBigFloat","text":"","title":"ConvertBigFloat"},{"location":"Route/Param/ConvertBigFloat/#ActionController::Route::Param::ConvertBigFloat-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertBigFloat/#ActionController::Route::Param::ConvertBigFloat#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertBigInt/","text":"struct ActionController::Route::Param::ConvertBigInt inherits ActionController::Route::Param::Conversion # Constructors # .new ( base : Int32 = 10 ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertBigInt"},{"location":"Route/Param/ConvertBigInt/#ActionController::Route::Param::ConvertBigInt","text":"","title":"ConvertBigInt"},{"location":"Route/Param/ConvertBigInt/#ActionController::Route::Param::ConvertBigInt-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertBigInt/#ActionController::Route::Param::ConvertBigInt.new(base)","text":"View source","title":".new"},{"location":"Route/Param/ConvertBigInt/#ActionController::Route::Param::ConvertBigInt-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertBigInt/#ActionController::Route::Param::ConvertBigInt#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertBool/","text":"struct ActionController::Route::Param::ConvertBool inherits ActionController::Route::Param::Conversion # Constructors # .new ( true_string : String = \"true\" ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertBool"},{"location":"Route/Param/ConvertBool/#ActionController::Route::Param::ConvertBool","text":"","title":"ConvertBool"},{"location":"Route/Param/ConvertBool/#ActionController::Route::Param::ConvertBool-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertBool/#ActionController::Route::Param::ConvertBool.new(true_string)","text":"View source","title":".new"},{"location":"Route/Param/ConvertBool/#ActionController::Route::Param::ConvertBool-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertBool/#ActionController::Route::Param::ConvertBool#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertChar/","text":"struct ActionController::Route::Param::ConvertChar inherits ActionController::Route::Param::Conversion # Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertChar"},{"location":"Route/Param/ConvertChar/#ActionController::Route::Param::ConvertChar","text":"","title":"ConvertChar"},{"location":"Route/Param/ConvertChar/#ActionController::Route::Param::ConvertChar-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertChar/#ActionController::Route::Param::ConvertChar#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertFloat32/","text":"struct ActionController::Route::Param::ConvertFloat32 inherits ActionController::Route::Param::Conversion # Float converters Constructors # .new ( whitespace : Bool = true , strict : Bool = true ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertFloat32"},{"location":"Route/Param/ConvertFloat32/#ActionController::Route::Param::ConvertFloat32","text":"Float converters","title":"ConvertFloat32"},{"location":"Route/Param/ConvertFloat32/#ActionController::Route::Param::ConvertFloat32-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertFloat32/#ActionController::Route::Param::ConvertFloat32.new(whitespace,strict)","text":"View source","title":".new"},{"location":"Route/Param/ConvertFloat32/#ActionController::Route::Param::ConvertFloat32-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertFloat32/#ActionController::Route::Param::ConvertFloat32#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertFloat64/","text":"struct ActionController::Route::Param::ConvertFloat64 inherits ActionController::Route::Param::Conversion # Constructors # .new ( whitespace : Bool = true , strict : Bool = true ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertFloat64"},{"location":"Route/Param/ConvertFloat64/#ActionController::Route::Param::ConvertFloat64","text":"","title":"ConvertFloat64"},{"location":"Route/Param/ConvertFloat64/#ActionController::Route::Param::ConvertFloat64-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertFloat64/#ActionController::Route::Param::ConvertFloat64.new(whitespace,strict)","text":"View source","title":".new"},{"location":"Route/Param/ConvertFloat64/#ActionController::Route::Param::ConvertFloat64-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertFloat64/#ActionController::Route::Param::ConvertFloat64#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertInt128/","text":"struct ActionController::Route::Param::ConvertInt128 inherits ActionController::Route::Param::Conversion # Constructors # .new ( base : Int32 = 10 , whitespace : Bool = true , underscore : Bool = false , prefix : Bool = false , strict : Bool = true , leading_zero_is_octal : Bool = false ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertInt128"},{"location":"Route/Param/ConvertInt128/#ActionController::Route::Param::ConvertInt128","text":"","title":"ConvertInt128"},{"location":"Route/Param/ConvertInt128/#ActionController::Route::Param::ConvertInt128-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertInt128/#ActionController::Route::Param::ConvertInt128.new(base,whitespace,underscore,prefix,strict,leading_zero_is_octal)","text":"View source","title":".new"},{"location":"Route/Param/ConvertInt128/#ActionController::Route::Param::ConvertInt128-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertInt128/#ActionController::Route::Param::ConvertInt128#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertInt16/","text":"struct ActionController::Route::Param::ConvertInt16 inherits ActionController::Route::Param::Conversion # Constructors # .new ( base : Int32 = 10 , whitespace : Bool = true , underscore : Bool = false , prefix : Bool = false , strict : Bool = true , leading_zero_is_octal : Bool = false ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertInt16"},{"location":"Route/Param/ConvertInt16/#ActionController::Route::Param::ConvertInt16","text":"","title":"ConvertInt16"},{"location":"Route/Param/ConvertInt16/#ActionController::Route::Param::ConvertInt16-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertInt16/#ActionController::Route::Param::ConvertInt16.new(base,whitespace,underscore,prefix,strict,leading_zero_is_octal)","text":"View source","title":".new"},{"location":"Route/Param/ConvertInt16/#ActionController::Route::Param::ConvertInt16-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertInt16/#ActionController::Route::Param::ConvertInt16#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertInt32/","text":"struct ActionController::Route::Param::ConvertInt32 inherits ActionController::Route::Param::Conversion # Constructors # .new ( base : Int32 = 10 , whitespace : Bool = true , underscore : Bool = false , prefix : Bool = false , strict : Bool = true , leading_zero_is_octal : Bool = false ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertInt32"},{"location":"Route/Param/ConvertInt32/#ActionController::Route::Param::ConvertInt32","text":"","title":"ConvertInt32"},{"location":"Route/Param/ConvertInt32/#ActionController::Route::Param::ConvertInt32-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertInt32/#ActionController::Route::Param::ConvertInt32.new(base,whitespace,underscore,prefix,strict,leading_zero_is_octal)","text":"View source","title":".new"},{"location":"Route/Param/ConvertInt32/#ActionController::Route::Param::ConvertInt32-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertInt32/#ActionController::Route::Param::ConvertInt32#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertInt64/","text":"struct ActionController::Route::Param::ConvertInt64 inherits ActionController::Route::Param::Conversion # Constructors # .new ( base : Int32 = 10 , whitespace : Bool = true , underscore : Bool = false , prefix : Bool = false , strict : Bool = true , leading_zero_is_octal : Bool = false ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertInt64"},{"location":"Route/Param/ConvertInt64/#ActionController::Route::Param::ConvertInt64","text":"","title":"ConvertInt64"},{"location":"Route/Param/ConvertInt64/#ActionController::Route::Param::ConvertInt64-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertInt64/#ActionController::Route::Param::ConvertInt64.new(base,whitespace,underscore,prefix,strict,leading_zero_is_octal)","text":"View source","title":".new"},{"location":"Route/Param/ConvertInt64/#ActionController::Route::Param::ConvertInt64-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertInt64/#ActionController::Route::Param::ConvertInt64#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertInt8/","text":"struct ActionController::Route::Param::ConvertInt8 inherits ActionController::Route::Param::Conversion # Integer converters Constructors # .new ( base : Int32 = 10 , whitespace : Bool = true , underscore : Bool = false , prefix : Bool = false , strict : Bool = true , leading_zero_is_octal : Bool = false ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertInt8"},{"location":"Route/Param/ConvertInt8/#ActionController::Route::Param::ConvertInt8","text":"Integer converters","title":"ConvertInt8"},{"location":"Route/Param/ConvertInt8/#ActionController::Route::Param::ConvertInt8-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertInt8/#ActionController::Route::Param::ConvertInt8.new(base,whitespace,underscore,prefix,strict,leading_zero_is_octal)","text":"View source","title":".new"},{"location":"Route/Param/ConvertInt8/#ActionController::Route::Param::ConvertInt8-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertInt8/#ActionController::Route::Param::ConvertInt8#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertString/","text":"struct ActionController::Route::Param::ConvertString inherits ActionController::Route::Param::Conversion # Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertString"},{"location":"Route/Param/ConvertString/#ActionController::Route::Param::ConvertString","text":"","title":"ConvertString"},{"location":"Route/Param/ConvertString/#ActionController::Route::Param::ConvertString-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertString/#ActionController::Route::Param::ConvertString#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertTime/","text":"struct ActionController::Route::Param::ConvertTime inherits ActionController::Route::Param::Conversion # Constructors # .new ( format : String? = nil ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertTime"},{"location":"Route/Param/ConvertTime/#ActionController::Route::Param::ConvertTime","text":"","title":"ConvertTime"},{"location":"Route/Param/ConvertTime/#ActionController::Route::Param::ConvertTime-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertTime/#ActionController::Route::Param::ConvertTime.new(format)","text":"View source","title":".new"},{"location":"Route/Param/ConvertTime/#ActionController::Route::Param::ConvertTime-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertTime/#ActionController::Route::Param::ConvertTime#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertUInt128/","text":"struct ActionController::Route::Param::ConvertUInt128 inherits ActionController::Route::Param::Conversion # Constructors # .new ( base : Int32 = 10 , whitespace : Bool = true , underscore : Bool = false , prefix : Bool = false , strict : Bool = true , leading_zero_is_octal : Bool = false ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertUInt128"},{"location":"Route/Param/ConvertUInt128/#ActionController::Route::Param::ConvertUInt128","text":"","title":"ConvertUInt128"},{"location":"Route/Param/ConvertUInt128/#ActionController::Route::Param::ConvertUInt128-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertUInt128/#ActionController::Route::Param::ConvertUInt128.new(base,whitespace,underscore,prefix,strict,leading_zero_is_octal)","text":"View source","title":".new"},{"location":"Route/Param/ConvertUInt128/#ActionController::Route::Param::ConvertUInt128-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertUInt128/#ActionController::Route::Param::ConvertUInt128#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertUInt16/","text":"struct ActionController::Route::Param::ConvertUInt16 inherits ActionController::Route::Param::Conversion # Constructors # .new ( base : Int32 = 10 , whitespace : Bool = true , underscore : Bool = false , prefix : Bool = false , strict : Bool = true , leading_zero_is_octal : Bool = false ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertUInt16"},{"location":"Route/Param/ConvertUInt16/#ActionController::Route::Param::ConvertUInt16","text":"","title":"ConvertUInt16"},{"location":"Route/Param/ConvertUInt16/#ActionController::Route::Param::ConvertUInt16-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertUInt16/#ActionController::Route::Param::ConvertUInt16.new(base,whitespace,underscore,prefix,strict,leading_zero_is_octal)","text":"View source","title":".new"},{"location":"Route/Param/ConvertUInt16/#ActionController::Route::Param::ConvertUInt16-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertUInt16/#ActionController::Route::Param::ConvertUInt16#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertUInt32/","text":"struct ActionController::Route::Param::ConvertUInt32 inherits ActionController::Route::Param::Conversion # Constructors # .new ( base : Int32 = 10 , whitespace : Bool = true , underscore : Bool = false , prefix : Bool = false , strict : Bool = true , leading_zero_is_octal : Bool = false ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertUInt32"},{"location":"Route/Param/ConvertUInt32/#ActionController::Route::Param::ConvertUInt32","text":"","title":"ConvertUInt32"},{"location":"Route/Param/ConvertUInt32/#ActionController::Route::Param::ConvertUInt32-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertUInt32/#ActionController::Route::Param::ConvertUInt32.new(base,whitespace,underscore,prefix,strict,leading_zero_is_octal)","text":"View source","title":".new"},{"location":"Route/Param/ConvertUInt32/#ActionController::Route::Param::ConvertUInt32-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertUInt32/#ActionController::Route::Param::ConvertUInt32#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertUInt64/","text":"struct ActionController::Route::Param::ConvertUInt64 inherits ActionController::Route::Param::Conversion # Constructors # .new ( base : Int32 = 10 , whitespace : Bool = true , underscore : Bool = false , prefix : Bool = false , strict : Bool = true , leading_zero_is_octal : Bool = false ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertUInt64"},{"location":"Route/Param/ConvertUInt64/#ActionController::Route::Param::ConvertUInt64","text":"","title":"ConvertUInt64"},{"location":"Route/Param/ConvertUInt64/#ActionController::Route::Param::ConvertUInt64-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertUInt64/#ActionController::Route::Param::ConvertUInt64.new(base,whitespace,underscore,prefix,strict,leading_zero_is_octal)","text":"View source","title":".new"},{"location":"Route/Param/ConvertUInt64/#ActionController::Route::Param::ConvertUInt64-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertUInt64/#ActionController::Route::Param::ConvertUInt64#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/ConvertUInt8/","text":"struct ActionController::Route::Param::ConvertUInt8 inherits ActionController::Route::Param::Conversion # Constructors # .new ( base : Int32 = 10 , whitespace : Bool = true , underscore : Bool = false , prefix : Bool = false , strict : Bool = true , leading_zero_is_octal : Bool = false ) # View source Methods # #convert ( raw : String ) # convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"::: ActionController::Route::Param::ConvertUInt8"},{"location":"Route/Param/ConvertUInt8/#ActionController::Route::Param::ConvertUInt8","text":"","title":"ConvertUInt8"},{"location":"Route/Param/ConvertUInt8/#ActionController::Route::Param::ConvertUInt8-constructors","text":"","title":"Constructors"},{"location":"Route/Param/ConvertUInt8/#ActionController::Route::Param::ConvertUInt8.new(base,whitespace,underscore,prefix,strict,leading_zero_is_octal)","text":"View source","title":".new"},{"location":"Route/Param/ConvertUInt8/#ActionController::Route::Param::ConvertUInt8-methods","text":"","title":"Methods"},{"location":"Route/Param/ConvertUInt8/#ActionController::Route::Param::ConvertUInt8#convert(raw)","text":"convert should typically return nil if the conversion failed this allows support for Union types, however may not be practical or desirable for most. Nilable Unions against a single type that raises an error is supported View source","title":"#convert"},{"location":"Route/Param/Error/","text":"class ActionController::Route::Param::Error inherits ArgumentError # Handle this to return a 404 Direct known subclasses ActionController::Route::Param::MissingError ActionController::Route::Param::ValueError Constructors # .new ( message , parameter : String? = nil , restriction : String? = nil ) # View source Methods # #parameter : String | :: Nil # View source #restriction : String | :: Nil # View source","title":"Param errors"},{"location":"Route/Param/Error/#ActionController::Route::Param::Error","text":"Handle this to return a 404","title":"Error"},{"location":"Route/Param/Error/#ActionController::Route::Param::Error-constructors","text":"","title":"Constructors"},{"location":"Route/Param/Error/#ActionController::Route::Param::Error.new(message,parameter,restriction)","text":"View source","title":".new"},{"location":"Route/Param/Error/#ActionController::Route::Param::Error-methods","text":"","title":"Methods"},{"location":"Route/Param/Error/#ActionController::Route::Param::Error#parameter","text":"View source","title":"#parameter"},{"location":"Route/Param/Error/#ActionController::Route::Param::Error#restriction","text":"View source","title":"#restriction"},{"location":"Route/Param/MissingError/","text":"class ActionController::Route::Param::MissingError inherits ActionController::Route::Param::Error #","title":"::: ActionController::Route::Param::MissingError"},{"location":"Route/Param/MissingError/#ActionController::Route::Param::MissingError","text":"","title":"MissingError"},{"location":"Route/Param/ValueError/","text":"class ActionController::Route::Param::ValueError inherits ActionController::Route::Param::Error #","title":"::: ActionController::Route::Param::ValueError"},{"location":"Route/Param/ValueError/#ActionController::Route::Param::ValueError","text":"","title":"ValueError"},{"location":"Route/UnsupportedMediaType/","text":"class ActionController::Route::UnsupportedMediaType inherits ActionController::Route::Error # we don't support the posted media type","title":"::: ActionController::Route::UnsupportedMediaType"},{"location":"Route/UnsupportedMediaType/#ActionController::Route::UnsupportedMediaType","text":"we don't support the posted media type","title":"UnsupportedMediaType"},{"location":"Route/WebSocket/","text":"annotation ActionController::Route::WebSocket #","title":"::: ActionController::Route::WebSocket"},{"location":"Route/WebSocket/#ActionController::Route::WebSocket","text":"","title":"WebSocket"},{"location":"Router/","text":"module ActionController::Router # Constants # HTTP_METHODS = [ \"get\" , \"post\" , \"put\" , \"patch\" , \"delete\" , \"options\" , \"head\" ] of :: String # Methods # #delete ( path : String , & block : Action ) # View source #get ( path : String , & block : Action ) # View source #head ( path : String , & block : Action ) # View source #options ( path : String , & block : Action ) # View source #patch ( path : String , & block : Action ) # View source #post ( path : String , & block : Action ) # View source #put ( path : String , & block : Action ) # View source #route_handler : RouteHandler # View source","title":"::: ActionController::Router"},{"location":"Router/#ActionController::Router","text":"","title":"Router"},{"location":"Router/#ActionController::Router-constants","text":"","title":"Constants"},{"location":"Router/#ActionController::Router::HTTP_METHODS","text":"","title":"HTTP_METHODS"},{"location":"Router/#ActionController::Router-methods","text":"","title":"Methods"},{"location":"Router/#ActionController::Router#delete(path,&)","text":"View source","title":"#delete"},{"location":"Router/#ActionController::Router#get(path,&)","text":"View source","title":"#get"},{"location":"Router/#ActionController::Router#head(path,&)","text":"View source","title":"#head"},{"location":"Router/#ActionController::Router#options(path,&)","text":"View source","title":"#options"},{"location":"Router/#ActionController::Router#patch(path,&)","text":"View source","title":"#patch"},{"location":"Router/#ActionController::Router#post(path,&)","text":"View source","title":"#post"},{"location":"Router/#ActionController::Router#put(path,&)","text":"View source","title":"#put"},{"location":"Router/#ActionController::Router#route_handler","text":"View source","title":"#route_handler"},{"location":"Router/Action/","text":"alias ActionController::Router::Action # Alias definition HTTP::Server::Context , Bool -> HTTP::Server::Context","title":"::: ActionController::Router::Action"},{"location":"Router/Action/#ActionController::Router::Action","text":"","title":"Action"},{"location":"Router/RouteHandler/","text":"class ActionController::Router::RouteHandler inherits Reference # Included modules HTTP::Handler Constructors # .new # View source Methods # #add_route ( method : String , path : String , action : Tuple ( Action , Bool )) # Adds a route handler to the system Determines if routes are static or require decomposition and stores them appropriately View source #call ( context : HTTP::Server::Context ) # Routes requests to the appropriate handler Called from HTTP::Server in server.cr View source #process_request ( search_path , context , controller_dispatch , head_request ) # We split out the processing of the request for simplified injection of telemetry View source #search_route ( method , req_path , search_path , context : HTTP::Server::Context ) : Tuple ( Action , Bool )? # Builds the internal representation of a route then searches static routes before checking the matcher View source","title":"::: ActionController::Router::RouteHandler"},{"location":"Router/RouteHandler/#ActionController::Router::RouteHandler","text":"","title":"RouteHandler"},{"location":"Router/RouteHandler/#ActionController::Router::RouteHandler-constructors","text":"","title":"Constructors"},{"location":"Router/RouteHandler/#ActionController::Router::RouteHandler.new","text":"View source","title":".new"},{"location":"Router/RouteHandler/#ActionController::Router::RouteHandler-methods","text":"","title":"Methods"},{"location":"Router/RouteHandler/#ActionController::Router::RouteHandler#add_route(method,path,action)","text":"Adds a route handler to the system Determines if routes are static or require decomposition and stores them appropriately View source","title":"#add_route"},{"location":"Router/RouteHandler/#ActionController::Router::RouteHandler#call(context)","text":"Routes requests to the appropriate handler Called from HTTP::Server in server.cr View source","title":"#call"},{"location":"Router/RouteHandler/#ActionController::Router::RouteHandler#process_request(search_path,context,controller_dispatch,head_request)","text":"We split out the processing of the request for simplified injection of telemetry View source","title":"#process_request"},{"location":"Router/RouteHandler/#ActionController::Router::RouteHandler#search_route(method,req_path,search_path,context)","text":"Builds the internal representation of a route then searches static routes before checking the matcher View source","title":"#search_route"},{"location":"Session/","text":"class ActionController::Session inherits Reference # Included modules Habitat::SettingsHelpers Habitat::TempConfig Constants # HABITAT_SETTINGS = [ { decl : key : String , example : nil , validation : nil }, { decl : secret : String , example : nil , validation : nil }, { decl : max_age : Int32 = NEVER , example : nil , validation : nil }, { decl : secure : Bool = false , example : nil , validation : nil }, { decl : encrypted : Bool = true , example : nil , validation : nil }, { decl : path : String = \"/\" , example : nil , validation : nil }, { decl : domain : String | :: Nil = nil , example : nil , validation : nil } ] of Nil # Log = :: Log . for ( \"action-controller.session\" ) # MAX_COOKIE_SIZE = 4096 # (~20 years in seconds) Cookies can typically store 4096 bytes. Cookies can typically store 4096 bytes. NEVER = 622080000 # Constructors # .new # View source Class methods # .configure # View source .from_cookies ( cookies ) # View source .settings # View source Methods # #[]= ( key , value ) # View source #clear # View source #delete ( key ) # View source #delete # View source #delete_if # View source #domain : String | :: Nil # View source #domain= ( domain : String? ) # View source #encode ( cookies ) # View source #modified : Bool # Returns whether any key-value pair is modified. View source #parse ( cookies ) # View source #reject # View source #settings # View source #touch # View source Macros # method_missing ( call ) # View source","title":"Session"},{"location":"Session/#ActionController::Session","text":"","title":"Session"},{"location":"Session/#ActionController::Session-constants","text":"","title":"Constants"},{"location":"Session/#ActionController::Session::HABITAT_SETTINGS","text":"","title":"HABITAT_SETTINGS"},{"location":"Session/#ActionController::Session::Log","text":"","title":"Log"},{"location":"Session/#ActionController::Session::MAX_COOKIE_SIZE","text":"(~20 years in seconds) Cookies can typically store 4096 bytes. Cookies can typically store 4096 bytes.","title":"MAX_COOKIE_SIZE"},{"location":"Session/#ActionController::Session::NEVER","text":"","title":"NEVER"},{"location":"Session/#ActionController::Session-constructors","text":"","title":"Constructors"},{"location":"Session/#ActionController::Session.new","text":"View source","title":".new"},{"location":"Session/#ActionController::Session-class-methods","text":"","title":"Class methods"},{"location":"Session/#ActionController::Session.configure(&)","text":"View source","title":".configure"},{"location":"Session/#ActionController::Session.from_cookies(cookies)","text":"View source","title":".from_cookies"},{"location":"Session/#ActionController::Session.settings","text":"View source","title":".settings"},{"location":"Session/#ActionController::Session-methods","text":"","title":"Methods"},{"location":"Session/#ActionController::Session#[]=(key,value)","text":"View source","title":"#[]="},{"location":"Session/#ActionController::Session#clear","text":"View source","title":"#clear"},{"location":"Session/#ActionController::Session#delete(key)","text":"View source","title":"#delete"},{"location":"Session/#ActionController::Session#delete_if(&)","text":"View source","title":"#delete_if"},{"location":"Session/#ActionController::Session#domain","text":"View source","title":"#domain"},{"location":"Session/#ActionController::Session#domain=(domain)","text":"View source","title":"#domain="},{"location":"Session/#ActionController::Session#encode(cookies)","text":"View source","title":"#encode"},{"location":"Session/#ActionController::Session#modified","text":"Returns whether any key-value pair is modified. View source","title":"#modified"},{"location":"Session/#ActionController::Session#parse(cookies)","text":"View source","title":"#parse"},{"location":"Session/#ActionController::Session#reject(&)","text":"View source","title":"#reject"},{"location":"Session/#ActionController::Session#settings","text":"View source","title":"#settings"},{"location":"Session/#ActionController::Session#touch","text":"View source","title":"#touch"},{"location":"Session/#ActionController::Session-macros","text":"","title":"Macros"},{"location":"Session/#ActionController::Session:method_missing(call)","text":"View source","title":"method_missing"},{"location":"Session/HabitatSettings/","text":"class ActionController::Session::HabitatSettings inherits Reference # Class methods # .domain : String | :: Nil # .domain= ( value : String? ) # .domain? # Used for checking missing settings on non-nilable types It's advised to use domain in your apps to ensure the propper type is checked. .encrypted : Bool # .encrypted= ( value : Bool ) # .encrypted? # Used for checking missing settings on non-nilable types It's advised to use encrypted in your apps to ensure the propper type is checked. .key : String # .key= ( value : String ) # .key? # Used for checking missing settings on non-nilable types It's advised to use key in your apps to ensure the propper type is checked. .max_age : Int32 # .max_age= ( value : Int32 ) # .max_age? # Used for checking missing settings on non-nilable types It's advised to use max_age in your apps to ensure the propper type is checked. .path : String # .path= ( value : String ) # .path? # Used for checking missing settings on non-nilable types It's advised to use path in your apps to ensure the propper type is checked. .secret : String # .secret= ( value : String ) # .secret? # Used for checking missing settings on non-nilable types It's advised to use secret in your apps to ensure the propper type is checked. .secure : Bool # .secure= ( value : Bool ) # .secure? # Used for checking missing settings on non-nilable types It's advised to use secure in your apps to ensure the propper type is checked. .to_h # Generates a hash using the provided values","title":"::: ActionController::Session::HabitatSettings"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings","text":"","title":"HabitatSettings"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings-class-methods","text":"","title":"Class methods"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.domain","text":"","title":".domain"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.domain=(value)","text":"","title":".domain="},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.domain?","text":"Used for checking missing settings on non-nilable types It's advised to use domain in your apps to ensure the propper type is checked.","title":".domain?"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.encrypted","text":"","title":".encrypted"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.encrypted=(value)","text":"","title":".encrypted="},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.encrypted?","text":"Used for checking missing settings on non-nilable types It's advised to use encrypted in your apps to ensure the propper type is checked.","title":".encrypted?"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.key","text":"","title":".key"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.key=(value)","text":"","title":".key="},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.key?","text":"Used for checking missing settings on non-nilable types It's advised to use key in your apps to ensure the propper type is checked.","title":".key?"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.max_age","text":"","title":".max_age"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.max_age=(value)","text":"","title":".max_age="},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.max_age?","text":"Used for checking missing settings on non-nilable types It's advised to use max_age in your apps to ensure the propper type is checked.","title":".max_age?"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.path","text":"","title":".path"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.path=(value)","text":"","title":".path="},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.path?","text":"Used for checking missing settings on non-nilable types It's advised to use path in your apps to ensure the propper type is checked.","title":".path?"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.secret","text":"","title":".secret"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.secret=(value)","text":"","title":".secret="},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.secret?","text":"Used for checking missing settings on non-nilable types It's advised to use secret in your apps to ensure the propper type is checked.","title":".secret?"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.secure","text":"","title":".secure"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.secure=(value)","text":"","title":".secure="},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.secure?","text":"Used for checking missing settings on non-nilable types It's advised to use secure in your apps to ensure the propper type is checked.","title":".secure?"},{"location":"Session/HabitatSettings/#ActionController::Session::HabitatSettings.to_h","text":"Generates a hash using the provided values","title":".to_h"},{"location":"Support/","text":"module ActionController::Support # Constants # TYPE_SEPARATOR_REGEX = /;\\s*/ # Class methods # .build_route ( route , hash_parts : Hash ( String | Symbol , Nil | Bool | Int32 | Int64 | Float32 | Float64 | String | Symbol )? = nil , ** tuple_parts ) # Used in base.cr to build routes for the redirect_to helpers View source .content_type ( headers ) # Extracts the mime type from the content type header View source .redirect_to_https ( context ) # View source .request_protocol ( request ) # View source .websocket_upgrade_request? ( request ) # View source","title":"Support"},{"location":"Support/#ActionController::Support","text":"","title":"Support"},{"location":"Support/#ActionController::Support-constants","text":"","title":"Constants"},{"location":"Support/#ActionController::Support::TYPE_SEPARATOR_REGEX","text":"","title":"TYPE_SEPARATOR_REGEX"},{"location":"Support/#ActionController::Support-class-methods","text":"","title":"Class methods"},{"location":"Support/#ActionController::Support.build_route(route,hash_parts,**)","text":"Used in base.cr to build routes for the redirect_to helpers View source","title":".build_route"},{"location":"Support/#ActionController::Support.content_type(headers)","text":"Extracts the mime type from the content type header View source","title":".content_type"},{"location":"Support/#ActionController::Support.redirect_to_https(context)","text":"View source","title":".redirect_to_https"},{"location":"Support/#ActionController::Support.request_protocol(request)","text":"View source","title":".request_protocol"},{"location":"Support/#ActionController::Support.websocket_upgrade_request?(request)","text":"View source","title":".websocket_upgrade_request?"},{"location":"configuration/","text":"Install Crystal Lang Clone the project template (and optionally mirror it) git clone https://github.com/spider-gazelle/spider-gazelle.git cd spider-gazelle git push --mirror https://github.com/exampleuser/new-project.git cd .. && git clone https://github.com/exampleuser/new-project.git Configuring your project # Common configuration options, such as your projects name and cookie key names, can be found in ./src/config.cr Running your project # crystal ./src/app.cr to have the project live reload as you develop Install NodeJS Install nodemon npm i -g nodemon then run the following command to have your project live reload nodemon --exec crystal ./src/app.cr Testing your project # Spider-Gazelle leverages crystal langs built in testing libraries to run tests: crystal spec or as you edit code: nodemon --exec crystal spec Compiling your project # crystal build ./src/app.cr or shards build --production grabs the latest dependencies before the build deploys the binary as per the compile target in your shard.yml once compiled there are a number of command line options execute ./app --help to see the options viewing routes ./app --routes run on a different port or host ./app -b 0.0.0.0 -p 80","title":"New Project"},{"location":"configuration/#configuring-your-project","text":"Common configuration options, such as your projects name and cookie key names, can be found in ./src/config.cr","title":"Configuring your project"},{"location":"configuration/#running-your-project","text":"crystal ./src/app.cr to have the project live reload as you develop Install NodeJS Install nodemon npm i -g nodemon then run the following command to have your project live reload nodemon --exec crystal ./src/app.cr","title":"Running your project"},{"location":"configuration/#testing-your-project","text":"Spider-Gazelle leverages crystal langs built in testing libraries to run tests: crystal spec or as you edit code: nodemon --exec crystal spec","title":"Testing your project"},{"location":"configuration/#compiling-your-project","text":"crystal build ./src/app.cr or shards build --production grabs the latest dependencies before the build deploys the binary as per the compile target in your shard.yml once compiled there are a number of command line options execute ./app --help to see the options viewing routes ./app --routes run on a different port or host ./app -b 0.0.0.0 -p 80","title":"Compiling your project"},{"location":"configuration/command_line/","text":"TODO::","title":"Command line options"},{"location":"configuration/logging/","text":"TODO::","title":"Logging and instrumentation"},{"location":"configuration/sessions/","text":"","title":"Sessions"},{"location":"deployment/","text":"Deploying your project # We use docker to package and distribute our applications to production. As such, this guide is opinionated and is by no means the only way to deploy your app. A quick thank you to Manus Tech for publishing their work in this area. Prerequisites # Some useful online tools: a docker hub account (free) optionally a codefresh account for fast auto-builds install docker for your operating system Creating a Docker image # This will create a docker image that is roughly 45 MiB in size, when using the default Dockerfile. in a terminal, cd into the application folder run: docker build -t dhub-user/spider-gazelle:latest . (latest is the default tag) this will create a docker image and tag it you can also run docker build . and then docker images if you don't have docker hub Then you can run the image locally if you like docker run -it --rm dhub-user/spider-gazelle To save this image for use in a deployment requires docker hub docker login docker push dhub-user/spider-gazelle Deployment # ssh into your server log into docker hub if using a private repo: docker login docker pull dhub-user/spider-gazelle docker run -d -p 8080:8080 --restart=always --name=spider-gazelle dhub-user/spider-gazelle -d means daemonize -p 8080:8080 maps the container port 8080 to the OS port 8080 --restart=always means the service should always be running (after computer restarts or app crashes) --name=spider-gazelle the name of the docker service you can now start and stop the service as you desire docker start spider-gazelle (if you named the service spider-gazelle) docker stop spider-gazelle docker restart spider-gazelle docker rm spider-gazelle (removes the service) Automated builds # If you would like your docker image to be ready to deploy every time you commit a change Github actions # We use github actions and the github repository for automated builds. Codefresh # One option we used in the past was codefresh as it ran faster when compared to docker hub. Login using your browser Click \"add repository\" Select your git repository (or add by URL) Select the branch to use for builds Docker Hub # Login on your browser Click \"create automated build\" select your git repository select your Dockerfile","title":"Deployment"},{"location":"deployment/#deploying-your-project","text":"We use docker to package and distribute our applications to production. As such, this guide is opinionated and is by no means the only way to deploy your app. A quick thank you to Manus Tech for publishing their work in this area.","title":"Deploying your project"},{"location":"deployment/#prerequisites","text":"Some useful online tools: a docker hub account (free) optionally a codefresh account for fast auto-builds install docker for your operating system","title":"Prerequisites"},{"location":"deployment/#creating-a-docker-image","text":"This will create a docker image that is roughly 45 MiB in size, when using the default Dockerfile. in a terminal, cd into the application folder run: docker build -t dhub-user/spider-gazelle:latest . (latest is the default tag) this will create a docker image and tag it you can also run docker build . and then docker images if you don't have docker hub Then you can run the image locally if you like docker run -it --rm dhub-user/spider-gazelle To save this image for use in a deployment requires docker hub docker login docker push dhub-user/spider-gazelle","title":"Creating a Docker image"},{"location":"deployment/#deployment","text":"ssh into your server log into docker hub if using a private repo: docker login docker pull dhub-user/spider-gazelle docker run -d -p 8080:8080 --restart=always --name=spider-gazelle dhub-user/spider-gazelle -d means daemonize -p 8080:8080 maps the container port 8080 to the OS port 8080 --restart=always means the service should always be running (after computer restarts or app crashes) --name=spider-gazelle the name of the docker service you can now start and stop the service as you desire docker start spider-gazelle (if you named the service spider-gazelle) docker stop spider-gazelle docker restart spider-gazelle docker rm spider-gazelle (removes the service)","title":"Deployment"},{"location":"deployment/#automated-builds","text":"If you would like your docker image to be ready to deploy every time you commit a change","title":"Automated builds"},{"location":"deployment/#github-actions","text":"We use github actions and the github repository for automated builds.","title":"Github actions"},{"location":"deployment/#codefresh","text":"One option we used in the past was codefresh as it ran faster when compared to docker hub. Login using your browser Click \"add repository\" Select your git repository (or add by URL) Select the branch to use for builds","title":"Codefresh"},{"location":"deployment/#docker-hub","text":"Login on your browser Click \"create automated build\" select your git repository select your Dockerfile","title":"Docker Hub"},{"location":"getting_started/","text":"Spider-Gazelle does not have any other dependencies outside of Crystal and Shards . It is designed in such a way to be non-intrusive, and not require a strict organizational convention in regards to how a project is setup; this allows it to use a minimal amount of setup boilerplate while not preventing it for more complex projects. Installation # Add the dependency to your shard.yml : dependencies : action-controller : github : spider-gazelle/action-controller version : ~> 5.1 Run shards install . Usage # Spider-Gazelle has a goal of being easy to start using for simple use cases, while still allowing flexibility/customizability for larger more complex use cases. Routing # Spider-Gazelle is a MVC based framework, as such, the logic to handle a given route is defined in an ActionController::Base class. require \"action-controller\" # Define a controller class ExampleController < AC :: Base # defaults to \"/example_controller\" overwrite with this directive base \"/\" # Define an action to handle the related route @[ AC::Route::GET ( \"/\" ) ] def index \"Hello World\" end # The macro DSL can also be used get \"/dsl\" do render text : \"Hello World\" end end # Run the server require \"action-controller/server\" AC :: Server . new . run # GET / # => Hello World Routing is handled via LuckyRouter for insanely fast route matching. See the routing documentation for more information. Controllers are simply classes and routes are simply methods. Controllers and actions can be documented/tested as you would any Crystal class/method. Route and Query Parameters # Arguments are converted to their expected types if possible, otherwise an error response is automatically returned. The values are provided directly as method arguments, thus preventing the need for params[\"name\"] and any boilerplate related to it. Just like normal method arguments, default values can be defined. The method's return type adds some type safety to ensure the expected value is being returned, however it is optional. require \"action-controller\" # base route is inferred off the class class Add < AC :: Base @[ AC::Route::GET ( \"/:value1/:value2\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) sum = value1 + value2 negative ? - sum : sum end end require \"action-controller/server\" AC :: Server . new . run # GET /add/2/3 # => 5 # GET /add/5/5?negative=true # => -10 # GET /add/foo/12 # => AC::Route::Param::ValueError<@message=\"invalid parameter value\" @parameter=\"value1\" @restriction=\"Int32\"> Route and query params are automatically inferred based on the route annotation and map directly to the method's arguments. See the related annotation docs for more information. require \"action-controller\" class ExampleController < AC :: Base base \"/\" @[ AC::Route::GET ( \"/\" , config : { page : { base : 16 }}) ] def index ( page : Int32 ) page end end require \"action-controller/server\" AC :: Server . new . run # GET / # => AC::Route::Param::MissingError<@message=\"missing required parameter\" @parameter=\"value1\" @restriction=\"Int32\"> # GET /?page=10 # => 16 (as we configured the page param to accept hex values) # GET /?page=bar # => AC::Route::Param::ValueError<@message=\"invalid parameter value\" @parameter=\"value1\" @restriction=\"Int32\"> Params can be customised at the argument level too using the @[AC::Param::Converter] annotation require \"action-controller\" class ExampleController < AC :: Base base \"/\" @[ AC::Route::GET ( \"/\" ) ] def index ( @[ AC::Param::Converter ( class : OptionalConvertorKlass , config : { base : 16 }, name : \"customParamName\" ) ] page : Int32 ) page end end require \"action-controller/server\" AC :: Server . new . run Body parsing # The request body can be accessed via the helper method request , request.body However it is recommended that the body be deserializing directly into an object require \"json\" require \"yaml\" require \"action-controller\" struct UserName include JSON :: Serializable include YAML :: Serializable getter id : String getter name : String end class ExampleController < AC :: Base base \"/\" @[ AC::Route::GET ( \"/data\" , body : :user ) ] def data ( user : UserName ) : String user . name end end require \"action-controller/server\" AC :: Server . new . run # POST /data body: {\"id\":1,\"name\":\"Jim\"} # => Jim Spider-Gazelle configures a JSON parser by default, however you can add custom parsers, configure a new default and also remove the JSON parser abstract class AppBase < AC :: Base add_parser ( \"application/yaml\" ) { | klass , body_io | klass . from_yaml ( body_io . gets_to_end ) } end You then use the Content-Type header to specify the format of your request body Responding # Responses are automatically rendered via a responder and selected using the requests Accept header You can also use the response object to fully customize the response; such as adding some one-off headers. require \"action-controller\" require \"yaml\" abstract class MyApplication < AC :: Base # the responder block is run in the context of the current controller instance # if you need access to the `request` or `response` or any other helpers to render the response add_responder ( \"application/yaml\" ) { | io , result , _klass_symbol , _method_symbol | result . to_yaml ( io ) } default_responder \"application/yaml\" end # Define a controller class ExampleController < MyApplication # defaults to \"/example_controller\" overwrite with this directive base \"/\" # Define an action to handle the related route @[ AC::Route::GET ( \"/\" ) ] def index \"Hello World\" end end require \"action-controller/server\" AC :: Server . new . run # GET / # => \"--- Hello World\" Error Handling # Unhandled exceptions are represented as a 500 Internal Server Error Error handlers can be defined gloabally, in your abstract base class, or specificially to a controller. require \"action-controller\" class Divide < AC :: Base @[ AC::Route::GET ( \"/:num1/:num2\" ) ] def divide ( num1 : Int32 , num2 : Int32 ) : Int32 num1 // num2 end @[ AC::Route::Exception ( DivisionByZeroError , status_code : HTTP :: Status :: BAD_REQUEST ) ] def division_by_zero ( error ) { error : error . message } end end require \"action-controller/server\" AC :: Server . new . run # GET /divide/10/0 # => {\"error\": \"Division by 0\"} # GET /divide_rescued/10/10 # => 1 Logging # Logging is handled via Crystal's Log module. Spider-Gazelle logs when a request matches a controller action, as well as any exception. This of course can be augmented with additional application specific messages. Here we're adding context to the logger that is valid for the lifetime of the request. require \"action-controller\" require \"uuid\" abstract class MyApplication < AC :: Base # NOTE:: you can chain this log from a base log instance Log = :: Log . for ( \"myapplication.controller\" ) @[ AC::Route::Filter ( :before_action ) ] def set_request_id request_id = UUID . random . to_s Log . context . set ( client_ip : client_ip , request_id : request_id ) response . headers [ \"X-Request-ID\" ] = request_id end end A new log context is provided for every request. All logs made during the lifetime of the request will be tagged with anything added to it. WebSockets # websockets can be defined just like any other route, this is a very basic chat room app (probably should have some locks etc) require \"action-controller\" class ExampleController < AC :: Base base \"/\" SOCKETS = Hash ( String , Array ( HTTP :: WebSocket )) { | hash , key | hash [ key ] = [] of HTTP :: WebSocket } @[ AC::Route::WebSocket ( \"/websocket/:room\" ) ] def websocket ( socket , room : String ) puts \"Socket opened\" sockets = SOCKETS [ room ] sockets << socket socket . on_message do | message | sockets . each &. send ( \" #{ message } + #{ @me } \" ) end socket . on_close do puts \"Socket closed\" sockets . size == 1 ? SOCKETS . delete ( room ) : sockets . delete ( socket ) end end end Filtering # Filters are methods that are run \"around\", \"before\" or \"after\" a controller action. Filters are inherited, so if you set a filter on a base Controller, it will be run on every controller in your application. around_action wraps all the before filters and the request, useful for setup database transactions before_action runs before the action method, useful for checking authentication, authorisation and loading resources required by the action (keep your code DRY) after_action run after the response data has been sent to the client, has access to the response Before filters # After filters can be used in the same way as before filters abstract class MyApplication < AC :: Base base \"/\" getter! user : User getter! comemnt : Comment @[ AC::Route::Filter ( :before_action , except : :login ) ] def get_current_user user_id = session [ \"user_id\" ]? render :unauthorized unless user_id @user = User . find! ( user_id ) end @[ AC::Route::Filter ( :before_action , only : [ :update_comment , :delete_comment ] ) ] def check_access ( id : Int64? ) if id @comment = Comment . find! ( id ) render :forbidden unless comment . user_id == user . id end end end Around filters # Around filters must yield to the action. abstract class MyApplication < AC :: Base base \"/\" @[ AC::Route::Filter ( :around_action , only : [ :create , :update , :destroy ] ) ] def wrap_in_transaction Database . transaction { yield } end end Skipping filters # If you have a filter on a base class like get_current_user above, you might want to skip this in another controller. abstract class MyApplication < AC :: Base getter! user : User @[ AC::Route::Filter ( :before_action , except : :login ) ] def get_current_user user_id = session [ \"user_id\" ]? render :unauthorized unless user_id @user = User . find! ( user_id ) end end class PublicController < MyApplication base \"/public\" skip_action :get_current_user , only : :index @[ AC::Route::GET ( \"/\" ) ] def index \"Hello World\" end end Force HTTPS protocol # Sometime you might want to force a particular controller to only be accessible via an HTTPS protocol for security reasons. You can use the force_ssl method in your controller to enforce that: class DinnerController < Application force_ssl end The request and response objects # In every controller there are two accessor methods pointing to the request and the response objects associated with the request cycle that is currently in execution. The request method contains an instance of HTTP::Request and the response method returns an instance of HTTP::Server::Response representing what is going to be sent back to the client. Setting custom headers # If you want to set custom headers for a response then response.headers is the place to do it. The headers attribute is a hash which maps header names to their values, and Spider-Gazelle will set some of them automatically. If you want to add or change a header, just assign it to response.headers this way: response . headers [ \"Content-Type\" ] = \"application/pdf\" in the above case it would make more sense to use the response.content_type setter directly.","title":"Getting Started"},{"location":"getting_started/#installation","text":"Add the dependency to your shard.yml : dependencies : action-controller : github : spider-gazelle/action-controller version : ~> 5.1 Run shards install .","title":"Installation"},{"location":"getting_started/#usage","text":"Spider-Gazelle has a goal of being easy to start using for simple use cases, while still allowing flexibility/customizability for larger more complex use cases.","title":"Usage"},{"location":"getting_started/#routing","text":"Spider-Gazelle is a MVC based framework, as such, the logic to handle a given route is defined in an ActionController::Base class. require \"action-controller\" # Define a controller class ExampleController < AC :: Base # defaults to \"/example_controller\" overwrite with this directive base \"/\" # Define an action to handle the related route @[ AC::Route::GET ( \"/\" ) ] def index \"Hello World\" end # The macro DSL can also be used get \"/dsl\" do render text : \"Hello World\" end end # Run the server require \"action-controller/server\" AC :: Server . new . run # GET / # => Hello World Routing is handled via LuckyRouter for insanely fast route matching. See the routing documentation for more information. Controllers are simply classes and routes are simply methods. Controllers and actions can be documented/tested as you would any Crystal class/method.","title":"Routing"},{"location":"getting_started/#route-and-query-parameters","text":"Arguments are converted to their expected types if possible, otherwise an error response is automatically returned. The values are provided directly as method arguments, thus preventing the need for params[\"name\"] and any boilerplate related to it. Just like normal method arguments, default values can be defined. The method's return type adds some type safety to ensure the expected value is being returned, however it is optional. require \"action-controller\" # base route is inferred off the class class Add < AC :: Base @[ AC::Route::GET ( \"/:value1/:value2\" ) ] def add ( value1 : Int32 , value2 : Int32 , negative : Bool = false ) sum = value1 + value2 negative ? - sum : sum end end require \"action-controller/server\" AC :: Server . new . run # GET /add/2/3 # => 5 # GET /add/5/5?negative=true # => -10 # GET /add/foo/12 # => AC::Route::Param::ValueError<@message=\"invalid parameter value\" @parameter=\"value1\" @restriction=\"Int32\"> Route and query params are automatically inferred based on the route annotation and map directly to the method's arguments. See the related annotation docs for more information. require \"action-controller\" class ExampleController < AC :: Base base \"/\" @[ AC::Route::GET ( \"/\" , config : { page : { base : 16 }}) ] def index ( page : Int32 ) page end end require \"action-controller/server\" AC :: Server . new . run # GET / # => AC::Route::Param::MissingError<@message=\"missing required parameter\" @parameter=\"value1\" @restriction=\"Int32\"> # GET /?page=10 # => 16 (as we configured the page param to accept hex values) # GET /?page=bar # => AC::Route::Param::ValueError<@message=\"invalid parameter value\" @parameter=\"value1\" @restriction=\"Int32\"> Params can be customised at the argument level too using the @[AC::Param::Converter] annotation require \"action-controller\" class ExampleController < AC :: Base base \"/\" @[ AC::Route::GET ( \"/\" ) ] def index ( @[ AC::Param::Converter ( class : OptionalConvertorKlass , config : { base : 16 }, name : \"customParamName\" ) ] page : Int32 ) page end end require \"action-controller/server\" AC :: Server . new . run","title":"Route and Query Parameters"},{"location":"getting_started/#body-parsing","text":"The request body can be accessed via the helper method request , request.body However it is recommended that the body be deserializing directly into an object require \"json\" require \"yaml\" require \"action-controller\" struct UserName include JSON :: Serializable include YAML :: Serializable getter id : String getter name : String end class ExampleController < AC :: Base base \"/\" @[ AC::Route::GET ( \"/data\" , body : :user ) ] def data ( user : UserName ) : String user . name end end require \"action-controller/server\" AC :: Server . new . run # POST /data body: {\"id\":1,\"name\":\"Jim\"} # => Jim Spider-Gazelle configures a JSON parser by default, however you can add custom parsers, configure a new default and also remove the JSON parser abstract class AppBase < AC :: Base add_parser ( \"application/yaml\" ) { | klass , body_io | klass . from_yaml ( body_io . gets_to_end ) } end You then use the Content-Type header to specify the format of your request body","title":"Body parsing"},{"location":"getting_started/#responding","text":"Responses are automatically rendered via a responder and selected using the requests Accept header You can also use the response object to fully customize the response; such as adding some one-off headers. require \"action-controller\" require \"yaml\" abstract class MyApplication < AC :: Base # the responder block is run in the context of the current controller instance # if you need access to the `request` or `response` or any other helpers to render the response add_responder ( \"application/yaml\" ) { | io , result , _klass_symbol , _method_symbol | result . to_yaml ( io ) } default_responder \"application/yaml\" end # Define a controller class ExampleController < MyApplication # defaults to \"/example_controller\" overwrite with this directive base \"/\" # Define an action to handle the related route @[ AC::Route::GET ( \"/\" ) ] def index \"Hello World\" end end require \"action-controller/server\" AC :: Server . new . run # GET / # => \"--- Hello World\"","title":"Responding"},{"location":"getting_started/#error-handling","text":"Unhandled exceptions are represented as a 500 Internal Server Error Error handlers can be defined gloabally, in your abstract base class, or specificially to a controller. require \"action-controller\" class Divide < AC :: Base @[ AC::Route::GET ( \"/:num1/:num2\" ) ] def divide ( num1 : Int32 , num2 : Int32 ) : Int32 num1 // num2 end @[ AC::Route::Exception ( DivisionByZeroError , status_code : HTTP :: Status :: BAD_REQUEST ) ] def division_by_zero ( error ) { error : error . message } end end require \"action-controller/server\" AC :: Server . new . run # GET /divide/10/0 # => {\"error\": \"Division by 0\"} # GET /divide_rescued/10/10 # => 1","title":"Error Handling"},{"location":"getting_started/#logging","text":"Logging is handled via Crystal's Log module. Spider-Gazelle logs when a request matches a controller action, as well as any exception. This of course can be augmented with additional application specific messages. Here we're adding context to the logger that is valid for the lifetime of the request. require \"action-controller\" require \"uuid\" abstract class MyApplication < AC :: Base # NOTE:: you can chain this log from a base log instance Log = :: Log . for ( \"myapplication.controller\" ) @[ AC::Route::Filter ( :before_action ) ] def set_request_id request_id = UUID . random . to_s Log . context . set ( client_ip : client_ip , request_id : request_id ) response . headers [ \"X-Request-ID\" ] = request_id end end A new log context is provided for every request. All logs made during the lifetime of the request will be tagged with anything added to it.","title":"Logging"},{"location":"getting_started/#websockets","text":"websockets can be defined just like any other route, this is a very basic chat room app (probably should have some locks etc) require \"action-controller\" class ExampleController < AC :: Base base \"/\" SOCKETS = Hash ( String , Array ( HTTP :: WebSocket )) { | hash , key | hash [ key ] = [] of HTTP :: WebSocket } @[ AC::Route::WebSocket ( \"/websocket/:room\" ) ] def websocket ( socket , room : String ) puts \"Socket opened\" sockets = SOCKETS [ room ] sockets << socket socket . on_message do | message | sockets . each &. send ( \" #{ message } + #{ @me } \" ) end socket . on_close do puts \"Socket closed\" sockets . size == 1 ? SOCKETS . delete ( room ) : sockets . delete ( socket ) end end end","title":"WebSockets"},{"location":"getting_started/#filtering","text":"Filters are methods that are run \"around\", \"before\" or \"after\" a controller action. Filters are inherited, so if you set a filter on a base Controller, it will be run on every controller in your application. around_action wraps all the before filters and the request, useful for setup database transactions before_action runs before the action method, useful for checking authentication, authorisation and loading resources required by the action (keep your code DRY) after_action run after the response data has been sent to the client, has access to the response","title":"Filtering"},{"location":"getting_started/#before-filters","text":"After filters can be used in the same way as before filters abstract class MyApplication < AC :: Base base \"/\" getter! user : User getter! comemnt : Comment @[ AC::Route::Filter ( :before_action , except : :login ) ] def get_current_user user_id = session [ \"user_id\" ]? render :unauthorized unless user_id @user = User . find! ( user_id ) end @[ AC::Route::Filter ( :before_action , only : [ :update_comment , :delete_comment ] ) ] def check_access ( id : Int64? ) if id @comment = Comment . find! ( id ) render :forbidden unless comment . user_id == user . id end end end","title":"Before filters"},{"location":"getting_started/#around-filters","text":"Around filters must yield to the action. abstract class MyApplication < AC :: Base base \"/\" @[ AC::Route::Filter ( :around_action , only : [ :create , :update , :destroy ] ) ] def wrap_in_transaction Database . transaction { yield } end end","title":"Around filters"},{"location":"getting_started/#skipping-filters","text":"If you have a filter on a base class like get_current_user above, you might want to skip this in another controller. abstract class MyApplication < AC :: Base getter! user : User @[ AC::Route::Filter ( :before_action , except : :login ) ] def get_current_user user_id = session [ \"user_id\" ]? render :unauthorized unless user_id @user = User . find! ( user_id ) end end class PublicController < MyApplication base \"/public\" skip_action :get_current_user , only : :index @[ AC::Route::GET ( \"/\" ) ] def index \"Hello World\" end end","title":"Skipping filters"},{"location":"getting_started/#force-https-protocol","text":"Sometime you might want to force a particular controller to only be accessible via an HTTPS protocol for security reasons. You can use the force_ssl method in your controller to enforce that: class DinnerController < Application force_ssl end","title":"Force HTTPS protocol"},{"location":"getting_started/#the-request-and-response-objects","text":"In every controller there are two accessor methods pointing to the request and the response objects associated with the request cycle that is currently in execution. The request method contains an instance of HTTP::Request and the response method returns an instance of HTTP::Server::Response representing what is going to be sent back to the client.","title":"The request and response objects"},{"location":"getting_started/#setting-custom-headers","text":"If you want to set custom headers for a response then response.headers is the place to do it. The headers attribute is a hash which maps header names to their values, and Spider-Gazelle will set some of them automatically. If you want to add or change a header, just assign it to response.headers this way: response . headers [ \"Content-Type\" ] = \"application/pdf\" in the above case it would make more sense to use the response.content_type setter directly.","title":"Setting custom headers"},{"location":"getting_started/openapi/","text":"Spider-Gazelle has the ability to ouput OpenAPI descriptions of the routes defined in your service. Output # The source code is required to output OpenAPI as we extract descriptions from regular comments. The simplest way to generate the OpenAPI YAML is to: build the application shards build generate the OpenAPI output ./bin/app --docs If you would like a file then run ./bin/app --docs > ./bin/description.yml You can then serve this document from your service when it's deployed if desirable. Optimal results # For optimal output it's recommended that you: decorate your route functions with return types (assumes no body if not decorated) decorate your models to improve JSON schema class Comments < Application base \"/comments\" # description of your model that will be used in the OpenAPI output class Comment include JSON :: Serializable # add format information to the output schema @[ JSON::Field ( format : \"email\" ) ] property reply_to : String property user_id : Int64 property text : String end # This is a route summary @[ AC::Route::GET ( \"/:comment_id\" ) ] def show ( comment_id : Int64 ) : Comment Comment . find ( comment_id ) end end Route descriptions # Summary and descriptions are extracted from the comments above the function that represents the route. the first line of the comment is used as a summary if there are multiple lines then all the lines are used as a description class Comments < Application base \"/comments\" # This is a route summary @[ AC::Route::GET ( \"/\" ) ] def index ; end # This is a route summary # This is a route description # and the description continued @[ AC::Route::POST ( \"/\" ) ] def create ; end end Schema descriptions # JSON schema is automatically extracted for all the types being serialised / deserialised including: Parameters (route and query) Request bodies Response bodies For JSON::Serializable types you can include additional information. class Comment include JSON :: Serializable # add format information to the output schema @[ JSON::Field ( format : \"email\" ) ] property reply_to : String property user_id : Int64 @[ JSON::Field ( format : \"email\" ) ] property text : String # The `EpochConverter` here means the JSON value will actually be an integer # to avoid the schema output being `type: \"string\", format: \"date-time\"` you can # supply a type override and custom format string. @[ JSON::Field ( converter : Time :: EpochConverter , type : \"integer\" , format : \"Int64\" ) ] getter time : Time end Some of the @[JSON::Field] annotations you can use are: type format pattern min_length max_length multiple_of minimum exclusive_minimum maximum exclusive_maximum as per the JSON Schema spec Custom types # If your model doesn't use JSON::Serializable and instead is using a custom serializer then you can implment def self.json_schema(openapi : Bool? = nil) to return a NamedTuple with the JSON Schema representation of your model.","title":"Self Documentation"},{"location":"getting_started/openapi/#output","text":"The source code is required to output OpenAPI as we extract descriptions from regular comments. The simplest way to generate the OpenAPI YAML is to: build the application shards build generate the OpenAPI output ./bin/app --docs If you would like a file then run ./bin/app --docs > ./bin/description.yml You can then serve this document from your service when it's deployed if desirable.","title":"Output"},{"location":"getting_started/openapi/#optimal-results","text":"For optimal output it's recommended that you: decorate your route functions with return types (assumes no body if not decorated) decorate your models to improve JSON schema class Comments < Application base \"/comments\" # description of your model that will be used in the OpenAPI output class Comment include JSON :: Serializable # add format information to the output schema @[ JSON::Field ( format : \"email\" ) ] property reply_to : String property user_id : Int64 property text : String end # This is a route summary @[ AC::Route::GET ( \"/:comment_id\" ) ] def show ( comment_id : Int64 ) : Comment Comment . find ( comment_id ) end end","title":"Optimal results"},{"location":"getting_started/openapi/#route-descriptions","text":"Summary and descriptions are extracted from the comments above the function that represents the route. the first line of the comment is used as a summary if there are multiple lines then all the lines are used as a description class Comments < Application base \"/comments\" # This is a route summary @[ AC::Route::GET ( \"/\" ) ] def index ; end # This is a route summary # This is a route description # and the description continued @[ AC::Route::POST ( \"/\" ) ] def create ; end end","title":"Route descriptions"},{"location":"getting_started/openapi/#schema-descriptions","text":"JSON schema is automatically extracted for all the types being serialised / deserialised including: Parameters (route and query) Request bodies Response bodies For JSON::Serializable types you can include additional information. class Comment include JSON :: Serializable # add format information to the output schema @[ JSON::Field ( format : \"email\" ) ] property reply_to : String property user_id : Int64 @[ JSON::Field ( format : \"email\" ) ] property text : String # The `EpochConverter` here means the JSON value will actually be an integer # to avoid the schema output being `type: \"string\", format: \"date-time\"` you can # supply a type override and custom format string. @[ JSON::Field ( converter : Time :: EpochConverter , type : \"integer\" , format : \"Int64\" ) ] getter time : Time end Some of the @[JSON::Field] annotations you can use are: type format pattern min_length max_length multiple_of minimum exclusive_minimum maximum exclusive_maximum as per the JSON Schema spec","title":"Schema descriptions"},{"location":"getting_started/openapi/#custom-types","text":"If your model doesn't use JSON::Serializable and instead is using a custom serializer then you can implment def self.json_schema(openapi : Bool? = nil) to return a NamedTuple with the JSON Schema representation of your model.","title":"Custom types"},{"location":"getting_started/routing/","text":"Controllers describe and handle routes. There are three methods for defining routes Strong Paramaters (recommended) Macro DSL Magic methods (legacy, remain for backwards compatibility, inspired by Rails) Strong Paramaters # This is the recommended method for routing. It conflates routing with the type casting of paramaters to help ensure program correctness by leveraging the type system. The paramater type casting also applies to filters and exception handlers, where the use of the current routes paramaters is desired. Verbs # The following verbs are provided class Comments < Application base \"/comments\" @[ AC::Route::GET ( \"/\" ) ] def index ; end @[ AC::Route::POST ( \"/\" ) ] def create ; end @[ AC::Route::PUT ( \"/:id\" ) ] def replace ( id : Int64 | String ); end @[ AC::Route::PATCH ( \"/:id\" ) ] def update ( id : Int64 ); end @[ AC::Route::DELETE ( \"/:id\" ) ] def destroy ( id : String ); end # optional id param @[ AC::Route::OPTIONS ( \"/?:id\" ) ] def options ( id : Int64 | String | Nil ); end end Defining routes # Route paramaters, as opposed to query paramaters, are defined as part of the URL path. you may mark parts of the path with a : to have a param with a matching name in the action i.e. /users/:some_user_id will result in a param named some_user_id /projects/:project_id/tasks/:task_id would have a project_id and task_id param generated route paramaters take precedence over any query paramaters with matching names optional paramaters are prefixed with a ? /users/?:some_user_id/groups allows the path segment some_user_id to be optional glob path allows multiple segments (i.e. captures a / value as part of the params) /path/*:path_to_file would match /path/my/file/location.cr , setting param[\"path_to_file\"] # => \"my/file/location.cr\" multiple routes can also be applied to a single function @[ AC::Route::GET ( \"/users/:id/groups\" ) ] @[ AC::Route::GET ( \"/users/groups\" ) ] def groups ( user_id : Int64? ); end however in the example above you could achieve the same thing with a single route @[AC::Route::GET(\"/users/?:id/groups\")] Extracting paramaters # Paramter extraction occurs accross the route params, query params and form data Take the following example: # This could be an DB ORM etc class MyModel include JSON :: Serializable include YAML :: Serializable getter x : Float64 getter y : Float64 end @[ AC::Route::PATCH ( \"/:id\" , body : :model ) ] def replace ( id : Int64 , model : MyModel , merge_arrays : Bool = false ); end the id is extracted from the route (the function paramater names are matched) merge_arrays is extracted from the query params and set to false if not provided the model being patched is extracted from the body and serialised according to the Content-Type header and matching parser Customising parsing # Parsers can be customised to parse types in various different ways @[ AC::Route::GET ( \"/:id\" , config : { time : { format : \"%F %:z\" }, degrees : { strict : false }, id : { base : 16 , underscore : true , strict : false } }) ] def replace ( id : Int64 , degrees : Float64 , time : Time ); end There are built in parsers for the following types Number types String Char Bool Time Enum You can find the custom options here Custom paramater parser # You can implement your own type parsers, they can be any class that implements def convert(raw : String) . Initiailizer arguments are the possible customisations. record Commit , branch : String , commit : String struct :: ActionController :: Route :: Param :: ConvertCommit # i.e. `\"master#742887\"` def convert ( raw : String ) branch , commit = raw . split ( '#' ) Commit . new ( branch , commit ) end end @[ AC::Route::GET ( \"/:commit\" ) ] def replace ( commit : Commit ); end any converter scoped to ActionController::Route::Param and class name starting with Convert will automatically be converted. If you would like to be more explicit: record Commit , branch : String , commit : String struct ConvertCommit # i.e. `\"master#742887\"` def convert ( raw : String ) branch , commit = raw . split ( '#' ) Commit . new ( branch , commit ) end end @[ AC::Route::GET ( \"/:commit\" , converters : { commit : ConvertCommit }) ] def replace ( commit : Commit ); end Response codes # By default all responses will return 200 OK. The default can be changed and response codes can be mapped to return types # change the default response code @[ AC::Route::GET ( \"/\" , status_code : HTTP :: Status :: ACCEPTED ) ] def replace ( commit : Commit ) end # map response codes to return types @[ AC::Route::GET ( \"/\" , status : { Int32 => HTTP :: Status :: OK , String => HTTP :: Status :: ACCEPTED , Float64 => HTTP :: Status :: CREATED }) ] def replace : Int32 | String | Float64 case rand ( 3 ) when 1 1 when 2 0.5 else \"wasn't 1 or 2\" end end Macro DSL # The macro DSL is the basis for all routing in spider-gazelle. This is as close to the metal as you can get. class MyPhotos < Application # ... # GET /my_photos/:id/features get \"/:id/features\" , :features do # e.g. render a list of features detected on the photo features = [] render json : features end # POST /my_photos/:id/feature post \"/my_photos/:id/feature\" , :feature do # add a feature to the photo head :ok end end In the example above we have created a new route with the name features defined by the :features symbol. This creates a function called features in the class MyPhotos class that can be used with filters. Customizing routes # You might want to define a route that isn't defined by the class name of the controller. This is also required if you would like to define a root route. class Welcome < Application base \"/\" @[ AC::Route::GET ( \"/\" ) ] def index ; end end Or to define a complex route class Features < Application base \"/my_photos/:photo_id/features\" # GET /my_photos/:photo_id/features/ @[ AC::Route::GET ( \"/\" ) ] def index ; end # GET /my_photos/:photo_id/features/:id @[ AC::Route::GET ( \"/:id\" ) ] def show ; end # POST /my_photos/:photo_id/features/ @[ AC::Route::POST ( \"/\" ) ] def create ; end end Magic methods, legacy # In Spider-Gazelle, a resourceful route provides a mapping between HTTP verbs and URLs to controller actions. By convention, each action also maps to a specific CRUD operation in a database. class MyPhotos < Application # base route defaults to the class name underscored # base 'my_photos' # GET /my_photos/ def index ; end # POST /my_photos/ def create ; end # GET /my_photos/:id def show ; end end The methods defined by the MyPhotos class define the routes that will be created. These are the routes that will be auto-generated if you define the appropriate method. HTTP Verb Path Controller#Action Used for GET /my_photos/ my_photos#index display a list of all your photos GET /my_photos/new my_photos#new return an HTML form for creating a new photo POST /my_photos/ my_photos#create create a new photo GET /my_photos/:id my_photos#show display a specific photo GET /my_photos/:id/edit my_photos#edit return an HTML form for editing a photo PATCH /my_photos/:id my_photos#update update a specific photo (possibly meta data) PUT /my_photos/:id my_photos#replace replace a specific photo DELETE /my_photos/:id my_photos#destroy delete a specific photo Because the router uses the HTTP verb and URL to match inbound requests, four URLs map to eight different actions. Redirecting to other routes # Routes are available as class level functions on the controllers. Consider the Features class above. Features . show ( \"photo_id\" , \"feature_id\" ) # => \"/my_photos/photo_id/features/feature_id\" : String This can be combined with the redirect helper redirect_to Features . show ( \"photo_id\" , \"feature_id\" ) Inspecting routes # To get a complete list of the available routes in your application execute the ./app --routes command in your terminal.","title":"Routing"},{"location":"getting_started/routing/#strong-paramaters","text":"This is the recommended method for routing. It conflates routing with the type casting of paramaters to help ensure program correctness by leveraging the type system. The paramater type casting also applies to filters and exception handlers, where the use of the current routes paramaters is desired.","title":"Strong Paramaters"},{"location":"getting_started/routing/#verbs","text":"The following verbs are provided class Comments < Application base \"/comments\" @[ AC::Route::GET ( \"/\" ) ] def index ; end @[ AC::Route::POST ( \"/\" ) ] def create ; end @[ AC::Route::PUT ( \"/:id\" ) ] def replace ( id : Int64 | String ); end @[ AC::Route::PATCH ( \"/:id\" ) ] def update ( id : Int64 ); end @[ AC::Route::DELETE ( \"/:id\" ) ] def destroy ( id : String ); end # optional id param @[ AC::Route::OPTIONS ( \"/?:id\" ) ] def options ( id : Int64 | String | Nil ); end end","title":"Verbs"},{"location":"getting_started/routing/#defining-routes","text":"Route paramaters, as opposed to query paramaters, are defined as part of the URL path. you may mark parts of the path with a : to have a param with a matching name in the action i.e. /users/:some_user_id will result in a param named some_user_id /projects/:project_id/tasks/:task_id would have a project_id and task_id param generated route paramaters take precedence over any query paramaters with matching names optional paramaters are prefixed with a ? /users/?:some_user_id/groups allows the path segment some_user_id to be optional glob path allows multiple segments (i.e. captures a / value as part of the params) /path/*:path_to_file would match /path/my/file/location.cr , setting param[\"path_to_file\"] # => \"my/file/location.cr\" multiple routes can also be applied to a single function @[ AC::Route::GET ( \"/users/:id/groups\" ) ] @[ AC::Route::GET ( \"/users/groups\" ) ] def groups ( user_id : Int64? ); end however in the example above you could achieve the same thing with a single route @[AC::Route::GET(\"/users/?:id/groups\")]","title":"Defining routes"},{"location":"getting_started/routing/#extracting-paramaters","text":"Paramter extraction occurs accross the route params, query params and form data Take the following example: # This could be an DB ORM etc class MyModel include JSON :: Serializable include YAML :: Serializable getter x : Float64 getter y : Float64 end @[ AC::Route::PATCH ( \"/:id\" , body : :model ) ] def replace ( id : Int64 , model : MyModel , merge_arrays : Bool = false ); end the id is extracted from the route (the function paramater names are matched) merge_arrays is extracted from the query params and set to false if not provided the model being patched is extracted from the body and serialised according to the Content-Type header and matching parser","title":"Extracting paramaters"},{"location":"getting_started/routing/#customising-parsing","text":"Parsers can be customised to parse types in various different ways @[ AC::Route::GET ( \"/:id\" , config : { time : { format : \"%F %:z\" }, degrees : { strict : false }, id : { base : 16 , underscore : true , strict : false } }) ] def replace ( id : Int64 , degrees : Float64 , time : Time ); end There are built in parsers for the following types Number types String Char Bool Time Enum You can find the custom options here","title":"Customising parsing"},{"location":"getting_started/routing/#custom-paramater-parser","text":"You can implement your own type parsers, they can be any class that implements def convert(raw : String) . Initiailizer arguments are the possible customisations. record Commit , branch : String , commit : String struct :: ActionController :: Route :: Param :: ConvertCommit # i.e. `\"master#742887\"` def convert ( raw : String ) branch , commit = raw . split ( '#' ) Commit . new ( branch , commit ) end end @[ AC::Route::GET ( \"/:commit\" ) ] def replace ( commit : Commit ); end any converter scoped to ActionController::Route::Param and class name starting with Convert will automatically be converted. If you would like to be more explicit: record Commit , branch : String , commit : String struct ConvertCommit # i.e. `\"master#742887\"` def convert ( raw : String ) branch , commit = raw . split ( '#' ) Commit . new ( branch , commit ) end end @[ AC::Route::GET ( \"/:commit\" , converters : { commit : ConvertCommit }) ] def replace ( commit : Commit ); end","title":"Custom paramater parser"},{"location":"getting_started/routing/#response-codes","text":"By default all responses will return 200 OK. The default can be changed and response codes can be mapped to return types # change the default response code @[ AC::Route::GET ( \"/\" , status_code : HTTP :: Status :: ACCEPTED ) ] def replace ( commit : Commit ) end # map response codes to return types @[ AC::Route::GET ( \"/\" , status : { Int32 => HTTP :: Status :: OK , String => HTTP :: Status :: ACCEPTED , Float64 => HTTP :: Status :: CREATED }) ] def replace : Int32 | String | Float64 case rand ( 3 ) when 1 1 when 2 0.5 else \"wasn't 1 or 2\" end end","title":"Response codes"},{"location":"getting_started/routing/#macro-dsl","text":"The macro DSL is the basis for all routing in spider-gazelle. This is as close to the metal as you can get. class MyPhotos < Application # ... # GET /my_photos/:id/features get \"/:id/features\" , :features do # e.g. render a list of features detected on the photo features = [] render json : features end # POST /my_photos/:id/feature post \"/my_photos/:id/feature\" , :feature do # add a feature to the photo head :ok end end In the example above we have created a new route with the name features defined by the :features symbol. This creates a function called features in the class MyPhotos class that can be used with filters.","title":"Macro DSL"},{"location":"getting_started/routing/#customizing-routes","text":"You might want to define a route that isn't defined by the class name of the controller. This is also required if you would like to define a root route. class Welcome < Application base \"/\" @[ AC::Route::GET ( \"/\" ) ] def index ; end end Or to define a complex route class Features < Application base \"/my_photos/:photo_id/features\" # GET /my_photos/:photo_id/features/ @[ AC::Route::GET ( \"/\" ) ] def index ; end # GET /my_photos/:photo_id/features/:id @[ AC::Route::GET ( \"/:id\" ) ] def show ; end # POST /my_photos/:photo_id/features/ @[ AC::Route::POST ( \"/\" ) ] def create ; end end","title":"Customizing routes"},{"location":"getting_started/routing/#magic-methods-legacy","text":"In Spider-Gazelle, a resourceful route provides a mapping between HTTP verbs and URLs to controller actions. By convention, each action also maps to a specific CRUD operation in a database. class MyPhotos < Application # base route defaults to the class name underscored # base 'my_photos' # GET /my_photos/ def index ; end # POST /my_photos/ def create ; end # GET /my_photos/:id def show ; end end The methods defined by the MyPhotos class define the routes that will be created. These are the routes that will be auto-generated if you define the appropriate method. HTTP Verb Path Controller#Action Used for GET /my_photos/ my_photos#index display a list of all your photos GET /my_photos/new my_photos#new return an HTML form for creating a new photo POST /my_photos/ my_photos#create create a new photo GET /my_photos/:id my_photos#show display a specific photo GET /my_photos/:id/edit my_photos#edit return an HTML form for editing a photo PATCH /my_photos/:id my_photos#update update a specific photo (possibly meta data) PUT /my_photos/:id my_photos#replace replace a specific photo DELETE /my_photos/:id my_photos#destroy delete a specific photo Because the router uses the HTTP verb and URL to match inbound requests, four URLs map to eight different actions.","title":"Magic methods, legacy"},{"location":"getting_started/routing/#redirecting-to-other-routes","text":"Routes are available as class level functions on the controllers. Consider the Features class above. Features . show ( \"photo_id\" , \"feature_id\" ) # => \"/my_photos/photo_id/features/feature_id\" : String This can be combined with the redirect helper redirect_to Features . show ( \"photo_id\" , \"feature_id\" )","title":"Redirecting to other routes"},{"location":"getting_started/routing/#inspecting-routes","text":"To get a complete list of the available routes in your application execute the ./app --routes command in your terminal.","title":"Inspecting routes"},{"location":"getting_started/sessions/","text":"Your application can have a session for each user in which you can store small amounts of data that will be persisted between requests. The session is only available in the controller and is stored using Cookies. The cookie data is cryptographically signed to make it tamper-proof. And it is also encrypted so anyone with access to it can't read its contents. (Spider-Gazelle will not accept it if it has been edited). The session cookie can store around 4kB of data. Storing large amounts of data in the session is discouraged. Typically store a user or session id in the session - which can be used to retrieve required data Configuration # Spider-Gazelle sets up a session key (the name of the cookie) and session secret when signing the session data. These can be changed in your applications config.cr file. Accessing the session # In your controller you can access the session through the session instance method. Sessions are lazily loaded. If you don't access sessions in your action's code, they will not be loaded. Hence you will never need to disable sessions, just not accessing them will do the job. Session values are stored using key/value pairs like a hash: class Application < ActionController :: Base # Finds the User with the ID stored in the session with the key # \"current_user_id\" This is a common way to handle user login in # a Spider-Gazelle application; logging in sets the session value # and logging out removes it. def current_user @current_user ||= session [ \"user_id\" ]? && User . find ( session [ \"user_id\" ] ) end end To store something in the session, just assign it to the key like a hash: class LoginController < Application # \"Create\" a login, aka \"log the user in\" @[ AC::Route::POST ( \"/\" ) ] def create ( username : String , password : String ) : Nil if user = User . authenticate ( username , password ) # Save the user ID in the session so it can be used in # subsequent requests session [ \"user_id\" ] = user . id end end end To remove something from the session, assign that key to be nil : class LoginController < Application # \"Delete\" a login, aka \"log the user out\" @[ AC::Route::DELETE ( \"/\" ) ] def destroy # Remove the user id from the session @current_user = session [ :user_id ] = nil end end To reset the entire session, use session.clear . Cookies # Your application can store small amounts of data on the client - called cookies - that will be persisted across requests and even sessions. Spider-Gazelle provides easy access to cookies via the cookies method, which - much like the session - works like a hash: class CommentsController < Application @[ AC::Route::GET ( \"/new\" ) ] def new # Auto-fill the commenter's name if it has been stored in a cookie comment = Comment . new ( author : cookies [ \"commenter_name\" ] ) comment end @[ AC::Route::POST ( \"/\" , body : :comment ) ] def create ( comment : Comment , remember_name : Bool = false ) comment . save! if remember_name # Remember the commenter's name. cookies [ \"commenter_name\" ] = comment . author else # Delete cookie for the commenter's name cookie, if any. cookies . delete ( \"commenter_name\" ) end comment end end","title":"Sessions and Cookies"},{"location":"getting_started/sessions/#configuration","text":"Spider-Gazelle sets up a session key (the name of the cookie) and session secret when signing the session data. These can be changed in your applications config.cr file.","title":"Configuration"},{"location":"getting_started/sessions/#accessing-the-session","text":"In your controller you can access the session through the session instance method. Sessions are lazily loaded. If you don't access sessions in your action's code, they will not be loaded. Hence you will never need to disable sessions, just not accessing them will do the job. Session values are stored using key/value pairs like a hash: class Application < ActionController :: Base # Finds the User with the ID stored in the session with the key # \"current_user_id\" This is a common way to handle user login in # a Spider-Gazelle application; logging in sets the session value # and logging out removes it. def current_user @current_user ||= session [ \"user_id\" ]? && User . find ( session [ \"user_id\" ] ) end end To store something in the session, just assign it to the key like a hash: class LoginController < Application # \"Create\" a login, aka \"log the user in\" @[ AC::Route::POST ( \"/\" ) ] def create ( username : String , password : String ) : Nil if user = User . authenticate ( username , password ) # Save the user ID in the session so it can be used in # subsequent requests session [ \"user_id\" ] = user . id end end end To remove something from the session, assign that key to be nil : class LoginController < Application # \"Delete\" a login, aka \"log the user out\" @[ AC::Route::DELETE ( \"/\" ) ] def destroy # Remove the user id from the session @current_user = session [ :user_id ] = nil end end To reset the entire session, use session.clear .","title":"Accessing the session"},{"location":"getting_started/sessions/#cookies","text":"Your application can store small amounts of data on the client - called cookies - that will be persisted across requests and even sessions. Spider-Gazelle provides easy access to cookies via the cookies method, which - much like the session - works like a hash: class CommentsController < Application @[ AC::Route::GET ( \"/new\" ) ] def new # Auto-fill the commenter's name if it has been stored in a cookie comment = Comment . new ( author : cookies [ \"commenter_name\" ] ) comment end @[ AC::Route::POST ( \"/\" , body : :comment ) ] def create ( comment : Comment , remember_name : Bool = false ) comment . save! if remember_name # Remember the commenter's name. cookies [ \"commenter_name\" ] = comment . author else # Delete cookie for the commenter's name cookie, if any. cookies . delete ( \"commenter_name\" ) end comment end end","title":"Cookies"},{"location":"getting_started/spec/","text":"Spider-Gazelle ships with a spec helper that leverages HotTopic so you can emulate the server and use HTTP::Client to perform tests. Spec Helper # Looking at the Spider-Gazelle template app , you'll want to split the following into seperate files the application config (controllers, models, logging, security, etc) the application entry point (command line parsing, starting the server etc) This way you can test the app without launching the server require \"spec\" # Helper methods for testing controllers (curl, with_server, context) require \"action-controller/spec_helper\" # Your application config require \"../src/config\" Testing routes # End to end testing a request describe YourController do # a hot topic client for testing your controllers client = AC :: SpecHelper . client # optional, use to change the response type headers = HTTP :: Headers { \"Accept\" => \"application/yaml\" , } it \"should welcome you with json\" do result = client . get ( \"/\" ) result . body . should eq %(\"You're being trampled by Spider-Gazelle!\") result . headers [ \"Date\" ]. should_not be_nil end it \"should welcome you with yaml\" do result = client . get ( \"/\" , headers : headers ) result . body . should eq \"--- You're being trampled by Spider-Gazelle! \\n \" result . headers [ \"Date\" ]. should_not be_nil end end Unit testing # Unit testing is possible by first grabbing an instance of a controller. describe YourController do # instantiate the controller you wish to unit test # the HTTP request constitues the server context, it is optional controller = YourController . spec_instance ( HTTP :: Request . new ( \"GET\" , \"/\" )) it \"should sum two numbers\" do welcome . add ( 10 , 30 ) . should eq 40 end end","title":"Writing Specs"},{"location":"getting_started/spec/#spec-helper","text":"Looking at the Spider-Gazelle template app , you'll want to split the following into seperate files the application config (controllers, models, logging, security, etc) the application entry point (command line parsing, starting the server etc) This way you can test the app without launching the server require \"spec\" # Helper methods for testing controllers (curl, with_server, context) require \"action-controller/spec_helper\" # Your application config require \"../src/config\"","title":"Spec Helper"},{"location":"getting_started/spec/#testing-routes","text":"End to end testing a request describe YourController do # a hot topic client for testing your controllers client = AC :: SpecHelper . client # optional, use to change the response type headers = HTTP :: Headers { \"Accept\" => \"application/yaml\" , } it \"should welcome you with json\" do result = client . get ( \"/\" ) result . body . should eq %(\"You're being trampled by Spider-Gazelle!\") result . headers [ \"Date\" ]. should_not be_nil end it \"should welcome you with yaml\" do result = client . get ( \"/\" , headers : headers ) result . body . should eq \"--- You're being trampled by Spider-Gazelle! \\n \" result . headers [ \"Date\" ]. should_not be_nil end end","title":"Testing routes"},{"location":"getting_started/spec/#unit-testing","text":"Unit testing is possible by first grabbing an instance of a controller. describe YourController do # instantiate the controller you wish to unit test # the HTTP request constitues the server context, it is optional controller = YourController . spec_instance ( HTTP :: Request . new ( \"GET\" , \"/\" )) it \"should sum two numbers\" do welcome . add ( 10 , 30 ) . should eq 40 end end","title":"Unit testing"}]}